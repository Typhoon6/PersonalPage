{"ast":null,"code":"/* eslint-disable */\n\n/*\n* DO NOT MODIFY, THIS IS AUTO GENERATED\n* Execute `npm run generate` to regenerate\n*/\nimport pMap from \"p-map\";\nimport NodeCache from \"node-cache\";\nimport PokeAPIOptions from \"./interfaces/PokeAPIOptions.js\";\nimport handleError from \"./utils/ErrorHandler.js\";\nimport getJSON from \"./utils/Getter.js\";\nexport default class Pokedex {\n  constructor(options) {\n    this.options = new PokeAPIOptions(options, new NodeCache());\n  }\n\n  async getResource(endpoint, callback) {\n    try {\n      if (!endpoint) {\n        throw new Error('Param \"endpoint\" is required needs to be a string or array of strings');\n      }\n\n      if (typeof endpoint === 'string') {\n        return getJSON(this.options, endpoint, callback);\n      } else if (typeof endpoint === 'object') {\n        const mapper = async endpoints => {\n          const queryRes = await getJSON(this.options, endpoints);\n          return queryRes;\n        }; // Fetch data asynchronously to be faster\n\n\n        const mappedResults = await pMap(endpoint, mapper, {\n          concurrency: 4\n        });\n\n        if (callback) {\n          callback(mappedResults);\n        }\n\n        return mappedResults;\n      } else {\n        throw new Error('Param \"endpoint\" needs to be a string or array of strings');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n  /** @deprecated - will be removed on the next version. Use {@link getResource} instead */\n\n\n  async resource(endpoint, callback) {\n    try {\n      if (!endpoint) {\n        throw new Error('Param \"endpoint\" is required needs to be a string or array of strings');\n      }\n\n      if (typeof endpoint === 'string') {\n        return getJSON(this.options, endpoint, callback);\n      } else if (typeof endpoint === 'object') {\n        const mapper = async endpoints => {\n          const queryRes = await getJSON(this.options, endpoints);\n          return queryRes;\n        }; // Fetch data asynchronously to be faster\n\n\n        const mappedResults = await pMap(endpoint, mapper, {\n          concurrency: 4\n        });\n\n        if (callback) {\n          callback(mappedResults);\n        }\n\n        return mappedResults;\n      } else {\n        throw new Error('Param \"endpoint\" needs to be a string or array of strings');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getBerryByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}berry/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}berry/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getBerryFirmnessByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}berry-firmness/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}berry-firmness/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getBerryFlavorByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}berry-flavor/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}berry-flavor/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getContestTypeByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}contest-type/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}contest-type/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getContestEffectById(id, callback) {\n    try {\n      if (id) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof id === 'number' || typeof id === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}contest-effect/${id}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof id === 'object') {\n          const mapper = async ids => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}contest-effect/${ids}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(id, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"id\" must be a number or array of numbers');\n        }\n      } else {\n        throw new Error('Param \"id\" is required (Must be a number or array of numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getSuperContestEffectById(id, callback) {\n    try {\n      if (id) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof id === 'number' || typeof id === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}super-contest-effect/${id}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof id === 'object') {\n          const mapper = async ids => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}super-contest-effect/${ids}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(id, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"id\" must be a number or array of numbers');\n        }\n      } else {\n        throw new Error('Param \"id\" is required (Must be a number or array of numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getEncounterMethodByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}encounter-method/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}encounter-method/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getEncounterConditionByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}encounter-condition/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}encounter-condition/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getEncounterConditionValueByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}encounter-condition-value/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}encounter-condition-value/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getEvolutionChainById(id, callback) {\n    try {\n      if (id) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof id === 'number' || typeof id === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}evolution-chain/${id}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof id === 'object') {\n          const mapper = async ids => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}evolution-chain/${ids}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(id, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"id\" must be a number or array of numbers');\n        }\n      } else {\n        throw new Error('Param \"id\" is required (Must be a number or array of numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getEvolutionTriggerByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}evolution-trigger/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}evolution-trigger/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getGenerationByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}generation/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}generation/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getPokedexByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokedex/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokedex/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getVersionByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}version/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}version/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getVersionGroupByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}version-group/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}version-group/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getItemByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}item/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}item/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getItemAttributeByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}item-attribute/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}item-attribute/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getItemCategoryByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}item-category/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}item-category/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getItemFlingEffectByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}item-fling-effect/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}item-fling-effect/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getItemPocketByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}item-pocket/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}item-pocket/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getMachineById(id, callback) {\n    try {\n      if (id) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof id === 'number' || typeof id === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}machine/${id}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof id === 'object') {\n          const mapper = async ids => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}machine/${ids}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(id, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"id\" must be a number or array of numbers');\n        }\n      } else {\n        throw new Error('Param \"id\" is required (Must be a number or array of numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getMoveByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getMoveAilmentByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move-ailment/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move-ailment/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getMoveBattleStyleByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move-battle-style/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move-battle-style/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getMoveCategoryByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move-category/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move-category/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getMoveDamageClassByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move-damage-class/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move-damage-class/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getMoveLearnMethodByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move-learn-method/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move-learn-method/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getMoveTargetByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move-target/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move-target/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getLocationByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}location/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}location/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getLocationAreaByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}location-area/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}location-area/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getPalParkAreaByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pal-park-area/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pal-park-area/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getRegionByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}region/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}region/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getAbilityByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}ability/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}ability/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getCharacteristicById(id, callback) {\n    try {\n      if (id) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof id === 'number' || typeof id === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}characteristic/${id}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof id === 'object') {\n          const mapper = async ids => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}characteristic/${ids}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(id, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"id\" must be a number or array of numbers');\n        }\n      } else {\n        throw new Error('Param \"id\" is required (Must be a number or array of numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getEggGroupByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}egg-group/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}egg-group/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getGenderByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}gender/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}gender/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getGrowthRateByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}growth-rate/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}growth-rate/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getNatureByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}nature/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}nature/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getPokeathlonStatByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokeathlon-stat/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokeathlon-stat/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getPokemonByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokemon/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokemon/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getPokemonColorByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokemon-color/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokemon-color/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getPokemonFormByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokemon-form/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokemon-form/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getPokemonHabitatByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokemon-habitat/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokemon-habitat/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getPokemonShapeByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokemon-shape/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokemon-shape/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getPokemonSpeciesByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokemon-species/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokemon-species/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getStatByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}stat/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}stat/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getTypeByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}type/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}type/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getLanguageByName(nameOrId, callback) {\n    try {\n      if (nameOrId) {\n        // If the user has submitted a Name or an ID, return the JSON promise\n        if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n          return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}language/${nameOrId}/`, callback);\n        } // If the user has submitted an Array return a new promise which will\n        // resolve when all getJSON calls are ended\n        else if (typeof nameOrId === 'object') {\n          const mapper = async nameOrIds => {\n            const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}language/${nameOrIds}/`);\n            return queryRes;\n          }; // Fetch data asynchronously to be faster\n\n\n          const mappedResults = await pMap(nameOrId, mapper, {\n            concurrency: 4\n          });\n\n          if (callback) {\n            callback(mappedResults);\n          }\n\n          return mappedResults;\n        } else {\n          throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n        }\n      } else {\n        throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n      }\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getBerriesList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}berry/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getBerriesFirmnessList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}berry-firmness/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n  /** @deprecated will be removed on a future version. Use {@link getBerriesFirmnessList} instead */\n\n\n  async getBerriesFirmnesssList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}berry-firmness/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getBerriesFlavorsList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}berry-flavor/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getContestTypesList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}contest-type/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getContestEffectsList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}contest-effect/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getSuperContestEffectsList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}super-contest-effect/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getEncounterMethodsList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}encounter-method/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getEncounterConditionsList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}encounter-condition/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getEncounterConditionValuesList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}encounter-condition-value/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getEvolutionChainsList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}evolution-chain/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getEvolutionTriggersList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}evolution-trigger/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getGenerationsList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}generation/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n  /** @deprecated will be removed on a future version. Use {@link getPokedexList} instead */\n\n\n  async getPokedexsList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokedex/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getPokedexList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokedex/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getVersionsList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}version/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getVersionGroupsList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}version-group/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getItemsList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}item/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getItemAttributesList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}item-attribute/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getItemCategoriesList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}item-category/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getItemFlingEffectsList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}item-fling-effect/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getItemPocketsList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}item-pocket/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getMachinesList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}machine/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getMovesList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getMoveAilmentsList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move-ailment/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getMoveBattleStylesList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move-battle-style/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getMoveCategoriesList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move-category/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getMoveDamageClassesList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move-damage-class/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getMoveLearnMethodsList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move-learn-method/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getMoveTargetsList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move-target/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getLocationsList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}location/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getLocationAreasList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}location-area/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getPalParkAreasList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pal-park-area/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getRegionsList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}region/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getAbilitiesList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}ability/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getCharacteristicsList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}characteristic/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getEggGroupsList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}egg-group/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getGendersList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}gender/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getGrowthRatesList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}growth-rate/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getNaturesList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}nature/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getPokeathlonStatsList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokeathlon-stat/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getPokemonsList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokemon/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getPokemonColorsList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokemon-color/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getPokemonFormsList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokemon-form/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getPokemonHabitatsList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokemon-habitat/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getPokemonShapesList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokemon-shape/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getPokemonSpeciesList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokemon-species/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getStatsList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}stat/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getTypesList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}type/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getLanguagesList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}language/?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n\n  async getEndpointsList(interval, callback) {\n    try {\n      let {\n        limit,\n        offset\n      } = this.options;\n\n      if (interval) {\n        if (interval.hasOwnProperty('limit')) {\n          limit = interval.limit;\n        }\n\n        if (interval.hasOwnProperty('offset')) {\n          offset = interval.offset;\n        }\n      }\n\n      return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}?limit=${limit}&offset=${offset}`, callback);\n    } catch (error) {\n      handleError(error, callback);\n    }\n  }\n  /** Retrieve the configs used */\n\n\n  getConfig() {\n    return this.options;\n  }\n  /** Retuns the current number of entries in the cache */\n\n\n  getCachedItemsCount() {\n    return this.options.cache.stats.keys;\n  }\n  /** @deprecated use {@link getCachedItemsCount} */\n\n\n  cacheSize() {\n    return this.options.cache.stats.keys;\n  }\n  /** Deletes all keys in cache */\n\n\n  clearCache() {\n    this.options.cache.flushAll();\n  }\n\n}","map":{"version":3,"sources":["C:/Users/admin/Downloads/Future/personal-project/node_modules/pokedex-promise-v2/dist/src/index.js"],"names":["pMap","NodeCache","PokeAPIOptions","handleError","getJSON","Pokedex","constructor","options","getResource","endpoint","callback","Error","mapper","endpoints","queryRes","mappedResults","concurrency","error","resource","getBerryByName","nameOrId","protocol","hostName","versionPath","nameOrIds","getBerryFirmnessByName","getBerryFlavorByName","getContestTypeByName","getContestEffectById","id","ids","getSuperContestEffectById","getEncounterMethodByName","getEncounterConditionByName","getEncounterConditionValueByName","getEvolutionChainById","getEvolutionTriggerByName","getGenerationByName","getPokedexByName","getVersionByName","getVersionGroupByName","getItemByName","getItemAttributeByName","getItemCategoryByName","getItemFlingEffectByName","getItemPocketByName","getMachineById","getMoveByName","getMoveAilmentByName","getMoveBattleStyleByName","getMoveCategoryByName","getMoveDamageClassByName","getMoveLearnMethodByName","getMoveTargetByName","getLocationByName","getLocationAreaByName","getPalParkAreaByName","getRegionByName","getAbilityByName","getCharacteristicById","getEggGroupByName","getGenderByName","getGrowthRateByName","getNatureByName","getPokeathlonStatByName","getPokemonByName","getPokemonColorByName","getPokemonFormByName","getPokemonHabitatByName","getPokemonShapeByName","getPokemonSpeciesByName","getStatByName","getTypeByName","getLanguageByName","getBerriesList","interval","limit","offset","hasOwnProperty","getBerriesFirmnessList","getBerriesFirmnesssList","getBerriesFlavorsList","getContestTypesList","getContestEffectsList","getSuperContestEffectsList","getEncounterMethodsList","getEncounterConditionsList","getEncounterConditionValuesList","getEvolutionChainsList","getEvolutionTriggersList","getGenerationsList","getPokedexsList","getPokedexList","getVersionsList","getVersionGroupsList","getItemsList","getItemAttributesList","getItemCategoriesList","getItemFlingEffectsList","getItemPocketsList","getMachinesList","getMovesList","getMoveAilmentsList","getMoveBattleStylesList","getMoveCategoriesList","getMoveDamageClassesList","getMoveLearnMethodsList","getMoveTargetsList","getLocationsList","getLocationAreasList","getPalParkAreasList","getRegionsList","getAbilitiesList","getCharacteristicsList","getEggGroupsList","getGendersList","getGrowthRatesList","getNaturesList","getPokeathlonStatsList","getPokemonsList","getPokemonColorsList","getPokemonFormsList","getPokemonHabitatsList","getPokemonShapesList","getPokemonSpeciesList","getStatsList","getTypesList","getLanguagesList","getEndpointsList","getConfig","getCachedItemsCount","cache","stats","keys","cacheSize","clearCache","flushAll"],"mappings":"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","sourcesContent":["/* eslint-disable */\n/*\n* DO NOT MODIFY, THIS IS AUTO GENERATED\n* Execute `npm run generate` to regenerate\n*/\nimport pMap from \"p-map\";\nimport NodeCache from \"node-cache\";\nimport PokeAPIOptions from \"./interfaces/PokeAPIOptions.js\";\nimport handleError from \"./utils/ErrorHandler.js\";\nimport getJSON from \"./utils/Getter.js\";\nexport default class Pokedex {\n    constructor(options) {\n        this.options = new PokeAPIOptions(options, new NodeCache());\n    }\n    async getResource(endpoint, callback) {\n        try {\n            if (!endpoint) {\n                throw new Error('Param \"endpoint\" is required needs to be a string or array of strings');\n            }\n            if (typeof endpoint === 'string') {\n                return getJSON(this.options, endpoint, callback);\n            }\n            else if (typeof endpoint === 'object') {\n                const mapper = async (endpoints) => {\n                    const queryRes = await getJSON(this.options, endpoints);\n                    return queryRes;\n                };\n                // Fetch data asynchronously to be faster\n                const mappedResults = await pMap(endpoint, mapper, { concurrency: 4 });\n                if (callback) {\n                    callback(mappedResults);\n                }\n                return mappedResults;\n            }\n            else {\n                throw new Error('Param \"endpoint\" needs to be a string or array of strings');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    /** @deprecated - will be removed on the next version. Use {@link getResource} instead */\n    async resource(endpoint, callback) {\n        try {\n            if (!endpoint) {\n                throw new Error('Param \"endpoint\" is required needs to be a string or array of strings');\n            }\n            if (typeof endpoint === 'string') {\n                return getJSON(this.options, endpoint, callback);\n            }\n            else if (typeof endpoint === 'object') {\n                const mapper = async (endpoints) => {\n                    const queryRes = await getJSON(this.options, endpoints);\n                    return queryRes;\n                };\n                // Fetch data asynchronously to be faster\n                const mappedResults = await pMap(endpoint, mapper, { concurrency: 4 });\n                if (callback) {\n                    callback(mappedResults);\n                }\n                return mappedResults;\n            }\n            else {\n                throw new Error('Param \"endpoint\" needs to be a string or array of strings');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getBerryByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}berry/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}berry/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getBerryFirmnessByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}berry-firmness/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}berry-firmness/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getBerryFlavorByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}berry-flavor/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}berry-flavor/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getContestTypeByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}contest-type/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}contest-type/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getContestEffectById(id, callback) {\n        try {\n            if (id) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof id === 'number' || typeof id === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}contest-effect/${id}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof id === 'object') {\n                    const mapper = async (ids) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}contest-effect/${ids}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(id, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"id\" must be a number or array of numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"id\" is required (Must be a number or array of numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getSuperContestEffectById(id, callback) {\n        try {\n            if (id) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof id === 'number' || typeof id === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}super-contest-effect/${id}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof id === 'object') {\n                    const mapper = async (ids) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}super-contest-effect/${ids}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(id, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"id\" must be a number or array of numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"id\" is required (Must be a number or array of numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getEncounterMethodByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}encounter-method/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}encounter-method/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getEncounterConditionByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}encounter-condition/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}encounter-condition/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getEncounterConditionValueByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}encounter-condition-value/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}encounter-condition-value/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getEvolutionChainById(id, callback) {\n        try {\n            if (id) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof id === 'number' || typeof id === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}evolution-chain/${id}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof id === 'object') {\n                    const mapper = async (ids) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}evolution-chain/${ids}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(id, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"id\" must be a number or array of numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"id\" is required (Must be a number or array of numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getEvolutionTriggerByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}evolution-trigger/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}evolution-trigger/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getGenerationByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}generation/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}generation/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getPokedexByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokedex/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokedex/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getVersionByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}version/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}version/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getVersionGroupByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}version-group/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}version-group/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getItemByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}item/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}item/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getItemAttributeByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}item-attribute/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}item-attribute/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getItemCategoryByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}item-category/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}item-category/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getItemFlingEffectByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}item-fling-effect/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}item-fling-effect/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getItemPocketByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}item-pocket/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}item-pocket/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getMachineById(id, callback) {\n        try {\n            if (id) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof id === 'number' || typeof id === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}machine/${id}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof id === 'object') {\n                    const mapper = async (ids) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}machine/${ids}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(id, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"id\" must be a number or array of numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"id\" is required (Must be a number or array of numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getMoveByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getMoveAilmentByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move-ailment/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move-ailment/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getMoveBattleStyleByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move-battle-style/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move-battle-style/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getMoveCategoryByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move-category/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move-category/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getMoveDamageClassByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move-damage-class/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move-damage-class/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getMoveLearnMethodByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move-learn-method/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move-learn-method/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getMoveTargetByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move-target/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move-target/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getLocationByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}location/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}location/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getLocationAreaByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}location-area/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}location-area/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getPalParkAreaByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pal-park-area/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pal-park-area/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getRegionByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}region/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}region/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getAbilityByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}ability/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}ability/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getCharacteristicById(id, callback) {\n        try {\n            if (id) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof id === 'number' || typeof id === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}characteristic/${id}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof id === 'object') {\n                    const mapper = async (ids) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}characteristic/${ids}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(id, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"id\" must be a number or array of numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"id\" is required (Must be a number or array of numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getEggGroupByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}egg-group/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}egg-group/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getGenderByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}gender/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}gender/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getGrowthRateByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}growth-rate/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}growth-rate/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getNatureByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}nature/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}nature/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getPokeathlonStatByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokeathlon-stat/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokeathlon-stat/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getPokemonByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokemon/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokemon/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getPokemonColorByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokemon-color/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokemon-color/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getPokemonFormByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokemon-form/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokemon-form/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getPokemonHabitatByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokemon-habitat/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokemon-habitat/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getPokemonShapeByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokemon-shape/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokemon-shape/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getPokemonSpeciesByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokemon-species/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokemon-species/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getStatByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}stat/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}stat/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getTypeByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}type/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}type/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getLanguageByName(nameOrId, callback) {\n        try {\n            if (nameOrId) {\n                // If the user has submitted a Name or an ID, return the JSON promise\n                if (typeof nameOrId === 'number' || typeof nameOrId === 'string') {\n                    return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}language/${nameOrId}/`, callback);\n                }\n                // If the user has submitted an Array return a new promise which will\n                // resolve when all getJSON calls are ended\n                else if (typeof nameOrId === 'object') {\n                    const mapper = async (nameOrIds) => {\n                        const queryRes = await getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}language/${nameOrIds}/`);\n                        return queryRes;\n                    };\n                    // Fetch data asynchronously to be faster\n                    const mappedResults = await pMap(nameOrId, mapper, { concurrency: 4 });\n                    if (callback) {\n                        callback(mappedResults);\n                    }\n                    return mappedResults;\n                }\n                else {\n                    throw new Error('Param \"nameOrId\" must be a string, array of strings or array of string and/or numbers');\n                }\n            }\n            else {\n                throw new Error('Param \"nameOrId\" is required (Must be a string, array of strings or array of string and/or numbers )');\n            }\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getBerriesList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}berry/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getBerriesFirmnessList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}berry-firmness/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    /** @deprecated will be removed on a future version. Use {@link getBerriesFirmnessList} instead */\n    async getBerriesFirmnesssList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}berry-firmness/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getBerriesFlavorsList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}berry-flavor/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getContestTypesList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}contest-type/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getContestEffectsList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}contest-effect/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getSuperContestEffectsList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}super-contest-effect/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getEncounterMethodsList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}encounter-method/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getEncounterConditionsList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}encounter-condition/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getEncounterConditionValuesList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}encounter-condition-value/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getEvolutionChainsList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}evolution-chain/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getEvolutionTriggersList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}evolution-trigger/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getGenerationsList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}generation/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    /** @deprecated will be removed on a future version. Use {@link getPokedexList} instead */\n    async getPokedexsList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokedex/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getPokedexList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokedex/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getVersionsList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}version/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getVersionGroupsList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}version-group/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getItemsList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}item/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getItemAttributesList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}item-attribute/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getItemCategoriesList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}item-category/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getItemFlingEffectsList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}item-fling-effect/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getItemPocketsList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}item-pocket/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getMachinesList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}machine/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getMovesList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getMoveAilmentsList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move-ailment/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getMoveBattleStylesList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move-battle-style/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getMoveCategoriesList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move-category/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getMoveDamageClassesList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move-damage-class/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getMoveLearnMethodsList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move-learn-method/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getMoveTargetsList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}move-target/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getLocationsList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}location/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getLocationAreasList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}location-area/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getPalParkAreasList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pal-park-area/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getRegionsList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}region/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getAbilitiesList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}ability/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getCharacteristicsList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}characteristic/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getEggGroupsList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}egg-group/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getGendersList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}gender/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getGrowthRatesList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}growth-rate/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getNaturesList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}nature/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getPokeathlonStatsList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokeathlon-stat/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getPokemonsList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokemon/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getPokemonColorsList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokemon-color/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getPokemonFormsList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokemon-form/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getPokemonHabitatsList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokemon-habitat/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getPokemonShapesList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokemon-shape/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getPokemonSpeciesList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}pokemon-species/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getStatsList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}stat/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getTypesList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}type/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getLanguagesList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}language/?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    async getEndpointsList(interval, callback) {\n        try {\n            let { limit, offset } = this.options;\n            if (interval) {\n                if (interval.hasOwnProperty('limit')) {\n                    limit = interval.limit;\n                }\n                if (interval.hasOwnProperty('offset')) {\n                    offset = interval.offset;\n                }\n            }\n            return getJSON(this.options, `${this.options.protocol}${this.options.hostName}${this.options.versionPath}?limit=${limit}&offset=${offset}`, callback);\n        }\n        catch (error) {\n            handleError(error, callback);\n        }\n    }\n    /** Retrieve the configs used */\n    getConfig() {\n        return this.options;\n    }\n    /** Retuns the current number of entries in the cache */\n    getCachedItemsCount() {\n        return this.options.cache.stats.keys;\n    }\n    /** @deprecated use {@link getCachedItemsCount} */\n    cacheSize() {\n        return this.options.cache.stats.keys;\n    }\n    /** Deletes all keys in cache */\n    clearCache() {\n        this.options.cache.flushAll();\n    }\n}\n"]},"metadata":{},"sourceType":"module"}