{"ast":null,"code":"/* ==========================================================\n   ========= Sudoku.js: Sudoku generator & JS LIBRARY =======\n   ========================================================== */ //(function(root){\n//var sudoku = root.sudoku = {};  // Global reference to the sudoku library\nvar sudoku={};sudoku.DIGITS=\"123456789\";// Allowed sudoku.DIGITS\nvar ROWS=\"ABCDEFGHI\";// Row lables\nvar COLS=sudoku.DIGITS;// Column lables\nvar SQUARES=null;// Square IDs\nvar UNITS=null;// All units (row, column, or box)\nvar SQUARE_UNITS_MAP=null;// Squares -> units map\nvar SQUARE_PEERS_MAP=null;// Squares -> peers map\nvar MIN_GIVENS=17;// Minimum number of givens\nvar NR_SQUARES=81;// Number of squares\n// Define difficulties by how many squares are given to the player in a new\n// puzzle.\nvar DIFFICULTY={\"easy\":62,\"medium\":53,\"hard\":44,\"very-hard\":35,\"insane\":26,\"inhuman\":17};// Blank character and board representation\nsudoku.BLANK_CHAR='.';sudoku.BLANK_BOARD=\"....................................................\"+\".............................\";// Init\n// -------------------------------------------------------------------------\nfunction initialize(){/* Initialize the Sudoku library (invoked after library load)\n        */SQUARES=sudoku._cross(ROWS,COLS);UNITS=sudoku._get_all_units(ROWS,COLS);SQUARE_UNITS_MAP=sudoku._get_square_units_map(SQUARES,UNITS);SQUARE_PEERS_MAP=sudoku._get_square_peers_map(SQUARES,SQUARE_UNITS_MAP);}// Generate\n// -------------------------------------------------------------------------\nsudoku.generate=function(difficulty,unique){/* Generate a new Sudoku puzzle of a particular `difficulty`, e.g.,\n\n            // Generate an \"easy\" sudoku puzzle\n            sudoku.generate(\"easy\");\n\n\n        Difficulties are as follows, and represent the number of given squares:\n\n                \"easy\":         61\n                \"medium\":       52\n                \"hard\":         43\n                \"very-hard\":    34\n                \"insane\":       25\n                \"inhuman\":      17\n\n\n        You may also enter a custom number of squares to be given, e.g.,\n\n            // Generate a new Sudoku puzzle with 60 given squares\n            sudoku.generate(60)\n\n\n        `difficulty` must be a number between 17 and 81 inclusive. If it's\n        outside of that range, `difficulty` will be set to the closest bound,\n        e.g., 0 -> 17, and 100 -> 81.\n\n\n        By default, the puzzles are unique, uless you set `unique` to false.\n        (Note: Puzzle uniqueness is not yet implemented, so puzzles are *not*\n        guaranteed to have unique solutions)\n\n        TODO: Implement puzzle uniqueness\n        */ // If `difficulty` is a string or undefined, convert it to a number or\n// default it to \"easy\" if undefined.\nif(typeof difficulty===\"string\"||typeof difficulty===\"undefined\"){difficulty=DIFFICULTY[difficulty]||DIFFICULTY.easy;}// Force difficulty between 17 and 81 inclusive\ndifficulty=sudoku._force_range(difficulty,NR_SQUARES+1,MIN_GIVENS);// Default unique to true\nunique=unique||true;// Get a set of squares and all possible candidates for each square\nvar blank_board=\"\";for(var i=0;i<NR_SQUARES;++i){blank_board+='.';}var candidates=sudoku._get_candidates_map(blank_board);// For each item in a shuffled list of squares\nvar shuffled_squares=sudoku._shuffle(SQUARES);for(var si in shuffled_squares){var square=shuffled_squares[si];// If an assignment of a random chioce causes a contradictoin, give\n// up and try again\nvar rand_candidate_idx=sudoku._rand_range(candidates[square].length);var rand_candidate=candidates[square][rand_candidate_idx];if(!sudoku._assign(candidates,square,rand_candidate)){break;}// Make a list of all single candidates\nvar single_candidates=[];for(si in SQUARES){square=SQUARES[si];if(candidates[square].length===1){single_candidates.push(candidates[square]);}}// If we have at least difficulty, and the unique candidate count is\n// at least 8, return the puzzle!\nif(single_candidates.length>=difficulty&&sudoku._strip_dups(single_candidates).length>=8){var board=\"\";var givens_idxs=[];for(i in SQUARES){square=SQUARES[i];if(candidates[square].length===1){board+=candidates[square];givens_idxs.push(i);}else{board+=sudoku.BLANK_CHAR;}}// If we have more than `difficulty` givens, remove some random\n// givens until we're down to exactly `difficulty`\nvar nr_givens=givens_idxs.length;if(nr_givens>difficulty){givens_idxs=sudoku._shuffle(givens_idxs);for(i=0;i<nr_givens-difficulty;++i){var target=parseInt(givens_idxs[i]);board=board.substr(0,target)+sudoku.BLANK_CHAR+board.substr(target+1);}}// Double check board is solvable\n// TODO: Make a standalone board checker. Solve is expensive.\nif(sudoku.solve(board)){return board;}}}// Give up and try a new puzzle\nreturn sudoku.generate(difficulty);};// Solve\n// -------------------------------------------------------------------------\nsudoku.solve=function(board,reverse){/* Solve a sudoku puzzle given a sudoku `board`, i.e., an 81-character\n        string of sudoku.DIGITS, 1-9, and spaces identified by '.', representing the\n        squares. There must be a minimum of 17 givens. If the given board has no\n        solutions, return false.\n\n        Optionally set `reverse` to solve \"backwards\", i.e., rotate through the\n        possibilities in reverse. Useful for checking if there is more than one\n        solution.\n        */ // Assure a valid board\nvar report=sudoku.validate_board(board);if(report!==true){throw report;}// Check number of givens is at least MIN_GIVENS\nvar nr_givens=0;for(var i in board){if(board[i]!==sudoku.BLANK_CHAR&&sudoku._in(board[i],sudoku.DIGITS)){++nr_givens;}}if(nr_givens<MIN_GIVENS){// eslint-disable-next-line\nthrow\"Too few givens. Minimum givens is \"+MIN_GIVENS;}// Default reverse to false\nreverse=reverse||false;var candidates=sudoku._get_candidates_map(board);var result=sudoku._search(candidates,reverse);if(result){var solution=\"\";for(var square in result){solution+=result[square];}return solution;}return false;};sudoku.get_candidates=function(board){/* Return all possible candidatees for each square as a grid of\n        candidates, returnning `false` if a contradiction is encountered.\n\n        Really just a wrapper for sudoku._get_candidates_map for programmer\n        consumption.\n        */ // Assure a valid board\nvar report=sudoku.validate_board(board);if(report!==true){throw report;}// Get a candidates map\nvar candidates_map=sudoku._get_candidates_map(board);// If there's an error, return false\nif(!candidates_map){return false;}// Transform candidates map into grid\nvar rows=[];var cur_row=[];var i=0;for(var square in candidates_map){var candidates=candidates_map[square];cur_row.push(candidates);if(i%9===8){rows.push(cur_row);cur_row=[];}++i;}return rows;};sudoku._get_candidates_map=function(board){/* Get all possible candidates for each square as a map in the form\n        {square: sudoku.DIGITS} using recursive constraint propagation. Return `false`\n        if a contradiction is encountered\n        */ // Assure a valid board\nvar report=sudoku.validate_board(board);if(report!==true){throw report;}var candidate_map={};var squares_values_map=sudoku._get_square_vals_map(board);// Start by assigning every digit as a candidate to every square\nfor(var si in SQUARES){candidate_map[SQUARES[si]]=sudoku.DIGITS;}// For each non-blank square, assign its value in the candidate map and\n// propigate.\nfor(var square in squares_values_map){var val=squares_values_map[square];if(sudoku._in(val,sudoku.DIGITS)){var new_candidates=sudoku._assign(candidate_map,square,val);// Fail if we can't assign val to square\nif(!new_candidates){return false;}}}return candidate_map;};sudoku._search=function(candidates,reverse){/* Given a map of squares -> candiates, using depth-first search,\n        recursively try all possible values until a solution is found, or false\n        if no solution exists.\n        */ // Return if error in previous iteration\nif(!candidates){return false;}// Default reverse to false\nreverse=reverse||false;// If only one candidate for every square, we've a solved puzzle!\n// Return the candidates map.\nvar max_nr_candidates=0;// eslint-disable-next-line\nvar max_candidates_square=null;for(var si in SQUARES){var square=SQUARES[si];var nr_candidates=candidates[square].length;if(nr_candidates>max_nr_candidates){max_nr_candidates=nr_candidates;// eslint-disable-next-line no-unused-vars\nmax_candidates_square=square;}}if(max_nr_candidates===1){return candidates;}// Choose the blank square with the fewest possibilities > 1\nvar min_nr_candidates=10;var min_candidates_square=null;for(si in SQUARES){square=SQUARES[si];nr_candidates=candidates[square].length;if(nr_candidates<min_nr_candidates&&nr_candidates>1){min_nr_candidates=nr_candidates;min_candidates_square=square;}}// Recursively search through each of the candidates of the square\n// starting with the one with fewest candidates.\n// Rotate through the candidates forwards\nvar min_candidates=candidates[min_candidates_square];if(!reverse){for(var vi in min_candidates){var val=min_candidates[vi];// TODO: Implement a non-rediculous deep copy function\nvar candidates_copy=JSON.parse(JSON.stringify(candidates));var candidates_next=sudoku._search(sudoku._assign(candidates_copy,min_candidates_square,val));if(candidates_next){return candidates_next;}}// Rotate through the candidates backwards\n}else{for(vi=min_candidates.length-1;vi>=0;--vi){val=min_candidates[vi];// TODO: Implement a non-rediculous deep copy function\ncandidates_copy=JSON.parse(JSON.stringify(candidates));candidates_next=sudoku._search(sudoku._assign(candidates_copy,min_candidates_square,val),reverse);if(candidates_next){return candidates_next;}}}// If we get through all combinations of the square with the fewest\n// candidates without finding an answer, there isn't one. Return false.\nreturn false;};sudoku._assign=function(candidates,square,val){/* Eliminate all values, *except* for `val`, from `candidates` at\n        `square` (candidates[square]), and propagate. Return the candidates map\n        when finished. If a contradiciton is found, return false.\n\n        WARNING: This will modify the contents of `candidates` directly.\n        */ // Grab a list of canidates without 'val'\nvar other_vals=candidates[square].replace(val,\"\");// Loop through all other values and eliminate them from the candidates\n// at the current square, and propigate. If at any point we get a\n// contradiction, return false.\nfor(var ovi in other_vals){var other_val=other_vals[ovi];var candidates_next=sudoku._eliminate(candidates,square,other_val);if(!candidates_next){//console.log(\"Contradiction found by _eliminate.\");\nreturn false;}}return candidates;};sudoku._eliminate=function(candidates,square,val){/* Eliminate `val` from `candidates` at `square`, (candidates[square]),\n        and propagate when values or places <= 2. Return updated candidates,\n        unless a contradiction is detected, in which case, return false.\n\n        WARNING: This will modify the contents of `candidates` directly.\n        */ // If `val` has already been eliminated from candidates[square], return\n// with candidates.\nif(!sudoku._in(val,candidates[square])){return candidates;}// Remove `val` from candidates[square]\ncandidates[square]=candidates[square].replace(val,'');// If the square has only candidate left, eliminate that value from its\n// peers\nvar nr_candidates=candidates[square].length;if(nr_candidates===1){var target_val=candidates[square];for(var pi in SQUARE_PEERS_MAP[square]){var peer=SQUARE_PEERS_MAP[square][pi];var candidates_new=sudoku._eliminate(candidates,peer,target_val);if(!candidates_new){return false;}}// Otherwise, if the square has no candidates, we have a contradiction.\n// Return false.\n}if(nr_candidates===0){return false;}// If a unit is reduced to only one place for a value, then assign it\nfor(var ui in SQUARE_UNITS_MAP[square]){var unit=SQUARE_UNITS_MAP[square][ui];var val_places=[];for(var si in unit){var unit_square=unit[si];if(sudoku._in(val,candidates[unit_square])){val_places.push(unit_square);}}// If there's no place for this value, we have a contradition!\n// return false\nif(val_places.length===0){return false;// Otherwise the value can only be in one place. Assign it there.\n}else if(val_places.length===1){candidates_new=sudoku._assign(candidates,val_places[0],val);if(!candidates_new){return false;}}}return candidates;};// Square relationships\n// -------------------------------------------------------------------------\n// Squares, and their relationships with values, units, and peers.\nsudoku._get_square_vals_map=function(board){/* Return a map of squares -> values\n        */var squares_vals_map={};// Make sure `board` is a string of length 81\nif(board.length!==SQUARES.length){// eslint-disable-next-line\nthrow\"Board/squares length mismatch.\";}else{for(var i in SQUARES){squares_vals_map[SQUARES[i]]=board[i];}}return squares_vals_map;};sudoku._get_square_units_map=function(squares,units){/* Return a map of `squares` and their associated units (row, col, box)\n        */var square_unit_map={};// For every square...\nfor(var si in squares){var cur_square=squares[si];// Maintain a list of the current square's units\nvar cur_square_units=[];// Look through the units, and see if the current square is in it,\n// and if so, add it to the list of of the square's units.\nfor(var ui in units){var cur_unit=units[ui];if(cur_unit.indexOf(cur_square)!==-1){cur_square_units.push(cur_unit);}}// Save the current square and its units to the map\nsquare_unit_map[cur_square]=cur_square_units;}return square_unit_map;};sudoku._get_square_peers_map=function(squares,units_map){/* Return a map of `squares` and their associated peers, i.e., a set of\n        other squares in the square's unit.\n        */var square_peers_map={};// For every square...\nfor(var si in squares){var cur_square=squares[si];var cur_square_units=units_map[cur_square];// Maintain list of the current square's peers\nvar cur_square_peers=[];// Look through the current square's units map...\nfor(var sui in cur_square_units){var cur_unit=cur_square_units[sui];for(var ui in cur_unit){var cur_unit_square=cur_unit[ui];if(cur_square_peers.indexOf(cur_unit_square)===-1&&cur_unit_square!==cur_square){cur_square_peers.push(cur_unit_square);}}}// Save the current square an its associated peers to the map\nsquare_peers_map[cur_square]=cur_square_peers;}return square_peers_map;};sudoku._get_all_units=function(rows,cols){/* Return a list of all units (rows, cols, boxes)\n        */var units=[];// Rows\nfor(var ri in rows){units.push(sudoku._cross(rows[ri],cols));}// Columns\nfor(var ci in cols){units.push(sudoku._cross(rows,cols[ci]));}// Boxes\nvar row_squares=[\"ABC\",\"DEF\",\"GHI\"];var col_squares=[\"123\",\"456\",\"789\"];for(var rsi in row_squares){for(var csi in col_squares){units.push(sudoku._cross(row_squares[rsi],col_squares[csi]));}}return units;};// Conversions\n// -------------------------------------------------------------------------\nsudoku.board_string_to_grid=function(board_string){/* Convert a board string to a two-dimensional array\n        */var rows=[];var cur_row=[];for(var i in board_string){cur_row.push(board_string[i]);if(i%9===8){rows.push(cur_row);cur_row=[];}}return rows;};sudoku.board_grid_to_string=function(board_grid){/* Convert a board grid to a string\n        */var board_string=\"\";for(var r=0;r<9;++r){for(var c=0;c<9;++c){board_string+=board_grid[r][c];}}return board_string;};// Utility\n// -------------------------------------------------------------------------\nsudoku.print_board=function(board){/* Print a sudoku `board` to the console.\n        */ // Assure a valid board\nvar report=sudoku.validate_board(board);if(report!==true){throw report;}var V_PADDING=\" \";// Insert after each square\nvar H_PADDING='\\n';// Insert after each row\nvar V_BOX_PADDING=\"  \";// Box vertical padding\nvar H_BOX_PADDING='\\n';// Box horizontal padding\nvar display_string=\"\";for(var i in board){var square=board[i];// Add the square and some padding\ndisplay_string+=square+V_PADDING;// Vertical edge of a box, insert v. box padding\nif(i%3===2){display_string+=V_BOX_PADDING;}// End of a line, insert horiz. padding\nif(i%9===8){display_string+=H_PADDING;}// Horizontal edge of a box, insert h. box padding\nif(i%27===26){display_string+=H_BOX_PADDING;}}console.log(display_string);};sudoku.validate_board=function(board){/* Return if the given `board` is valid or not. If it's valid, return\n        true. If it's not, return a string of the reason why it's not.\n        */ // Check for empty board\nif(!board){return\"Empty board\";}// Invalid board length\nif(board.length!==NR_SQUARES){return\"Invalid board size. Board must be exactly \"+NR_SQUARES+\" squares.\";}// Check for invalid characters\nfor(var i in board){if(!sudoku._in(board[i],sudoku.DIGITS)&&board[i]!==sudoku.BLANK_CHAR){return\"Invalid board character encountered at index \"+i+\": \"+board[i];}}// Otherwise, we're good. Return true.\nreturn true;};sudoku._cross=function(a,b){/* Cross product of all elements in `a` and `b`, e.g.,\n        sudoku._cross(\"abc\", \"123\") ->\n        [\"a1\", \"a2\", \"a3\", \"b1\", \"b2\", \"b3\", \"c1\", \"c2\", \"c3\"]\n        */var result=[];for(var ai in a){for(var bi in b){result.push(a[ai]+b[bi]);}}return result;};sudoku._in=function(v,seq){/* Return if a value `v` is in sequence `seq`.\n        */return seq.indexOf(v)!==-1;};sudoku._first_true=function(seq){/* Return the first element in `seq` that is true. If no element is\n        true, return false.\n        */for(var i in seq){if(seq[i]){return seq[i];}}return false;};sudoku._shuffle=function(seq){/* Return a shuffled version of `seq`\n        */ // Create an array of the same size as `seq` filled with false\nvar shuffled=[];for(var i=0;i<seq.length;++i){shuffled.push(false);}for(i in seq){var ti=sudoku._rand_range(seq.length);while(shuffled[ti]){ti=ti+1>seq.length-1?0:ti+1;}shuffled[ti]=seq[i];}return shuffled;};sudoku._rand_range=function(max,min){/* Get a random integer in the range of `min` to `max` (non inclusive).\n        If `min` not defined, default to 0. If `max` not defined, throw an\n        error.\n        */min=min||0;if(max){return Math.floor(Math.random()*(max-min))+min;}else{// eslint-disable-next-line\nthrow\"Range undefined\";}};sudoku._strip_dups=function(seq){/* Strip duplicate values from `seq`\n        */var seq_set=[];var dup_map={};for(var i in seq){var e=seq[i];if(!dup_map[e]){seq_set.push(e);dup_map[e]=true;}}return seq_set;};sudoku._force_range=function(nr,max,min){/* Force `nr` to be within the range from `min` to, but not including,\n        `max`. `min` is optional, and will default to 0. If `nr` is undefined,\n        treat it as zero.\n        */min=min||0;nr=nr||0;if(nr<min){return min;}if(nr>max){return max;}return nr;};// Initialize library after load\ninitialize();export var getSudoku=function getSudoku(){return sudoku;};// Pass whatever the root object is, like 'window' in browsers\n//})(this);","map":{"version":3,"sources":["C:/Users/admin/Downloads/Future/personal-project/src/pages/Sudoku/solver/sudoku.js"],"names":["sudoku","DIGITS","ROWS","COLS","SQUARES","UNITS","SQUARE_UNITS_MAP","SQUARE_PEERS_MAP","MIN_GIVENS","NR_SQUARES","DIFFICULTY","BLANK_CHAR","BLANK_BOARD","initialize","_cross","_get_all_units","_get_square_units_map","_get_square_peers_map","generate","difficulty","unique","easy","_force_range","blank_board","i","candidates","_get_candidates_map","shuffled_squares","_shuffle","si","square","rand_candidate_idx","_rand_range","length","rand_candidate","_assign","single_candidates","push","_strip_dups","board","givens_idxs","nr_givens","target","parseInt","substr","solve","reverse","report","validate_board","_in","result","_search","solution","get_candidates","candidates_map","rows","cur_row","candidate_map","squares_values_map","_get_square_vals_map","val","new_candidates","max_nr_candidates","max_candidates_square","nr_candidates","min_nr_candidates","min_candidates_square","min_candidates","vi","candidates_copy","JSON","parse","stringify","candidates_next","other_vals","replace","ovi","other_val","_eliminate","target_val","pi","peer","candidates_new","ui","unit","val_places","unit_square","squares_vals_map","squares","units","square_unit_map","cur_square","cur_square_units","cur_unit","indexOf","units_map","square_peers_map","cur_square_peers","sui","cur_unit_square","cols","ri","ci","row_squares","col_squares","rsi","csi","board_string_to_grid","board_string","board_grid_to_string","board_grid","r","c","print_board","V_PADDING","H_PADDING","V_BOX_PADDING","H_BOX_PADDING","display_string","console","log","a","b","ai","bi","v","seq","_first_true","shuffled","ti","max","min","Math","floor","random","seq_set","dup_map","e","nr","getSudoku"],"mappings":"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","sourcesContent":["/* ==========================================================\n   ========= Sudoku.js: Sudoku generator & JS LIBRARY =======\n   ========================================================== */\n\n//(function(root){\n    //var sudoku = root.sudoku = {};  // Global reference to the sudoku library\n    var sudoku = {};\n    sudoku.DIGITS = \"123456789\";    // Allowed sudoku.DIGITS\n    var ROWS = \"ABCDEFGHI\";         // Row lables\n    var COLS = sudoku.DIGITS;       // Column lables\n    var SQUARES = null;             // Square IDs\n\n    var UNITS = null;               // All units (row, column, or box)\n    var SQUARE_UNITS_MAP = null;    // Squares -> units map\n    var SQUARE_PEERS_MAP = null;    // Squares -> peers map\n\n    var MIN_GIVENS = 17;            // Minimum number of givens\n    var NR_SQUARES = 81;            // Number of squares\n\n    // Define difficulties by how many squares are given to the player in a new\n    // puzzle.\n    var DIFFICULTY = {\n        \"easy\":         62,\n        \"medium\":       53,\n        \"hard\":         44,\n        \"very-hard\":    35,\n        \"insane\":       26,\n        \"inhuman\":      17,\n    };\n\n    // Blank character and board representation\n    sudoku.BLANK_CHAR = '.';\n    sudoku.BLANK_BOARD = \"....................................................\"+\n            \".............................\";\n\n    // Init\n    // -------------------------------------------------------------------------\n    function initialize(){\n        /* Initialize the Sudoku library (invoked after library load)\n        */\n        SQUARES             = sudoku._cross(ROWS, COLS);\n        UNITS               = sudoku._get_all_units(ROWS, COLS);\n        SQUARE_UNITS_MAP    = sudoku._get_square_units_map(SQUARES, UNITS);\n        SQUARE_PEERS_MAP    = sudoku._get_square_peers_map(SQUARES,\n                                    SQUARE_UNITS_MAP);\n    }\n\n    // Generate\n    // -------------------------------------------------------------------------\n    sudoku.generate = function(difficulty, unique){\n        /* Generate a new Sudoku puzzle of a particular `difficulty`, e.g.,\n\n            // Generate an \"easy\" sudoku puzzle\n            sudoku.generate(\"easy\");\n\n\n        Difficulties are as follows, and represent the number of given squares:\n\n                \"easy\":         61\n                \"medium\":       52\n                \"hard\":         43\n                \"very-hard\":    34\n                \"insane\":       25\n                \"inhuman\":      17\n\n\n        You may also enter a custom number of squares to be given, e.g.,\n\n            // Generate a new Sudoku puzzle with 60 given squares\n            sudoku.generate(60)\n\n\n        `difficulty` must be a number between 17 and 81 inclusive. If it's\n        outside of that range, `difficulty` will be set to the closest bound,\n        e.g., 0 -> 17, and 100 -> 81.\n\n\n        By default, the puzzles are unique, uless you set `unique` to false.\n        (Note: Puzzle uniqueness is not yet implemented, so puzzles are *not*\n        guaranteed to have unique solutions)\n\n        TODO: Implement puzzle uniqueness\n        */\n\n        // If `difficulty` is a string or undefined, convert it to a number or\n        // default it to \"easy\" if undefined.\n        if(typeof difficulty === \"string\" || typeof difficulty === \"undefined\"){\n            difficulty = DIFFICULTY[difficulty] || DIFFICULTY.easy;\n        }\n\n        // Force difficulty between 17 and 81 inclusive\n        difficulty = sudoku._force_range(difficulty, NR_SQUARES + 1,\n                MIN_GIVENS);\n\n        // Default unique to true\n        unique = unique || true;\n\n        // Get a set of squares and all possible candidates for each square\n        var blank_board = \"\";\n        for(var i = 0; i < NR_SQUARES; ++i){\n            blank_board += '.';\n        }\n        var candidates = sudoku._get_candidates_map(blank_board);\n\n        // For each item in a shuffled list of squares\n        var shuffled_squares = sudoku._shuffle(SQUARES);\n        for(var si in shuffled_squares){\n            var square = shuffled_squares[si];\n\n            // If an assignment of a random chioce causes a contradictoin, give\n            // up and try again\n            var rand_candidate_idx =\n                    sudoku._rand_range(candidates[square].length);\n            var rand_candidate = candidates[square][rand_candidate_idx];\n            if(!sudoku._assign(candidates, square, rand_candidate)){\n                break;\n            }\n\n            // Make a list of all single candidates\n            var single_candidates = [];\n            for(si in SQUARES){\n                square = SQUARES[si];\n\n                if(candidates[square].length === 1){\n                    single_candidates.push(candidates[square]);\n                }\n            }\n\n            // If we have at least difficulty, and the unique candidate count is\n            // at least 8, return the puzzle!\n            if(single_candidates.length >= difficulty &&\n                    sudoku._strip_dups(single_candidates).length >= 8){\n                var board = \"\";\n                var givens_idxs = [];\n                for(i in SQUARES){\n                    square = SQUARES[i];\n                    if(candidates[square].length === 1){\n                        board += candidates[square];\n                        givens_idxs.push(i);\n                    } else {\n                        board += sudoku.BLANK_CHAR;\n                    }\n                }\n\n                // If we have more than `difficulty` givens, remove some random\n                // givens until we're down to exactly `difficulty`\n                var nr_givens = givens_idxs.length;\n                if(nr_givens > difficulty){\n                    givens_idxs = sudoku._shuffle(givens_idxs);\n                    for(i = 0; i < nr_givens - difficulty; ++i){\n                        var target = parseInt(givens_idxs[i]);\n                        board = board.substr(0, target) + sudoku.BLANK_CHAR +\n                            board.substr(target + 1);\n                    }\n                }\n\n                // Double check board is solvable\n                // TODO: Make a standalone board checker. Solve is expensive.\n                if(sudoku.solve(board)){\n                    return board;\n                }\n            }\n        }\n\n        // Give up and try a new puzzle\n        return sudoku.generate(difficulty);\n    };\n\n    // Solve\n    // -------------------------------------------------------------------------\n    sudoku.solve = function(board, reverse){\n        /* Solve a sudoku puzzle given a sudoku `board`, i.e., an 81-character\n        string of sudoku.DIGITS, 1-9, and spaces identified by '.', representing the\n        squares. There must be a minimum of 17 givens. If the given board has no\n        solutions, return false.\n\n        Optionally set `reverse` to solve \"backwards\", i.e., rotate through the\n        possibilities in reverse. Useful for checking if there is more than one\n        solution.\n        */\n\n        // Assure a valid board\n        var report = sudoku.validate_board(board);\n        if(report !== true){\n            throw report;\n        }\n\n        // Check number of givens is at least MIN_GIVENS\n        var nr_givens = 0;\n        for(var i in board){\n            if(board[i] !== sudoku.BLANK_CHAR && sudoku._in(board[i], sudoku.DIGITS)){\n                ++nr_givens;\n            }\n        }\n        if(nr_givens < MIN_GIVENS){\n            // eslint-disable-next-line\n            throw \"Too few givens. Minimum givens is \" + MIN_GIVENS;\n        }\n\n        // Default reverse to false\n        reverse = reverse || false;\n\n        var candidates = sudoku._get_candidates_map(board);\n        var result = sudoku._search(candidates, reverse);\n\n        if(result){\n            var solution = \"\";\n            for(var square in result){\n                solution += result[square];\n            }\n            return solution;\n        }\n        return false;\n    };\n\n    sudoku.get_candidates = function(board){\n        /* Return all possible candidatees for each square as a grid of\n        candidates, returnning `false` if a contradiction is encountered.\n\n        Really just a wrapper for sudoku._get_candidates_map for programmer\n        consumption.\n        */\n\n        // Assure a valid board\n        var report = sudoku.validate_board(board);\n        if(report !== true){\n            throw report;\n        }\n\n        // Get a candidates map\n        var candidates_map = sudoku._get_candidates_map(board);\n\n        // If there's an error, return false\n        if(!candidates_map){\n            return false;\n        }\n\n        // Transform candidates map into grid\n        var rows = [];\n        var cur_row = [];\n        var i = 0;\n        for(var square in candidates_map){\n            var candidates = candidates_map[square];\n            cur_row.push(candidates);\n            if(i % 9 === 8){\n                rows.push(cur_row);\n                cur_row = [];\n            }\n            ++i;\n        }\n        return rows;\n    }\n\n    sudoku._get_candidates_map = function(board){\n        /* Get all possible candidates for each square as a map in the form\n        {square: sudoku.DIGITS} using recursive constraint propagation. Return `false`\n        if a contradiction is encountered\n        */\n\n        // Assure a valid board\n        var report = sudoku.validate_board(board);\n        if(report !== true){\n            throw report;\n        }\n\n        var candidate_map = {};\n        var squares_values_map = sudoku._get_square_vals_map(board);\n\n        // Start by assigning every digit as a candidate to every square\n        for(var si in SQUARES){\n            candidate_map[SQUARES[si]] = sudoku.DIGITS;\n        }\n\n        // For each non-blank square, assign its value in the candidate map and\n        // propigate.\n        for(var square in squares_values_map){\n            var val = squares_values_map[square];\n\n            if(sudoku._in(val, sudoku.DIGITS)){\n                var new_candidates = sudoku._assign(candidate_map, square, val);\n\n                // Fail if we can't assign val to square\n                if(!new_candidates){\n                    return false;\n                }\n            }\n        }\n\n        return candidate_map;\n    };\n\n    sudoku._search = function(candidates, reverse){\n        /* Given a map of squares -> candiates, using depth-first search,\n        recursively try all possible values until a solution is found, or false\n        if no solution exists.\n        */\n\n        // Return if error in previous iteration\n        if(!candidates){\n            return false;\n        }\n\n        // Default reverse to false\n        reverse = reverse || false;\n\n        // If only one candidate for every square, we've a solved puzzle!\n        // Return the candidates map.\n        var max_nr_candidates = 0;\n        // eslint-disable-next-line\n        var max_candidates_square = null;\n        for(var si in SQUARES){\n            var square = SQUARES[si];\n\n            var nr_candidates = candidates[square].length;\n\n            if(nr_candidates > max_nr_candidates){\n                max_nr_candidates = nr_candidates;\n                // eslint-disable-next-line no-unused-vars\n                max_candidates_square = square;\n            }\n        }\n        if(max_nr_candidates === 1){\n            return candidates;\n        }\n\n        // Choose the blank square with the fewest possibilities > 1\n        var min_nr_candidates = 10;\n        var min_candidates_square = null;\n        for(si in SQUARES){\n            square = SQUARES[si];\n\n            nr_candidates = candidates[square].length;\n\n            if(nr_candidates < min_nr_candidates && nr_candidates > 1){\n                min_nr_candidates = nr_candidates;\n                min_candidates_square = square;\n            }\n        }\n\n        // Recursively search through each of the candidates of the square\n        // starting with the one with fewest candidates.\n\n        // Rotate through the candidates forwards\n        var min_candidates = candidates[min_candidates_square];\n        if(!reverse){\n            for(var vi in min_candidates){\n                var val = min_candidates[vi];\n\n                // TODO: Implement a non-rediculous deep copy function\n                var candidates_copy = JSON.parse(JSON.stringify(candidates));\n                var candidates_next = sudoku._search(\n                    sudoku._assign(candidates_copy, min_candidates_square, val)\n                );\n\n                if(candidates_next){\n                    return candidates_next;\n                }\n            }\n\n        // Rotate through the candidates backwards\n        } else {\n            for(vi = min_candidates.length - 1; vi >= 0; --vi){\n                val = min_candidates[vi];\n\n                // TODO: Implement a non-rediculous deep copy function\n                candidates_copy = JSON.parse(JSON.stringify(candidates));\n                candidates_next = sudoku._search(\n                    sudoku._assign(candidates_copy, min_candidates_square, val),\n                    reverse\n                );\n\n                if(candidates_next){\n                    return candidates_next;\n                }\n            }\n        }\n\n        // If we get through all combinations of the square with the fewest\n        // candidates without finding an answer, there isn't one. Return false.\n        return false;\n    };\n\n    sudoku._assign = function(candidates, square, val){\n        /* Eliminate all values, *except* for `val`, from `candidates` at\n        `square` (candidates[square]), and propagate. Return the candidates map\n        when finished. If a contradiciton is found, return false.\n\n        WARNING: This will modify the contents of `candidates` directly.\n        */\n\n        // Grab a list of canidates without 'val'\n        var other_vals = candidates[square].replace(val, \"\");\n\n        // Loop through all other values and eliminate them from the candidates\n        // at the current square, and propigate. If at any point we get a\n        // contradiction, return false.\n        for(var ovi in other_vals){\n            var other_val = other_vals[ovi];\n\n            var candidates_next =\n                sudoku._eliminate(candidates, square, other_val);\n\n            if(!candidates_next){\n                //console.log(\"Contradiction found by _eliminate.\");\n                return false;\n            }\n        }\n\n        return candidates;\n    };\n\n    sudoku._eliminate = function(candidates, square, val){\n        /* Eliminate `val` from `candidates` at `square`, (candidates[square]),\n        and propagate when values or places <= 2. Return updated candidates,\n        unless a contradiction is detected, in which case, return false.\n\n        WARNING: This will modify the contents of `candidates` directly.\n        */\n\n        // If `val` has already been eliminated from candidates[square], return\n        // with candidates.\n        if(!sudoku._in(val, candidates[square])){\n            return candidates;\n        }\n\n        // Remove `val` from candidates[square]\n        candidates[square] = candidates[square].replace(val, '');\n\n        // If the square has only candidate left, eliminate that value from its\n        // peers\n        var nr_candidates = candidates[square].length;\n        if(nr_candidates === 1){\n            var target_val = candidates[square];\n\n            for(var pi in SQUARE_PEERS_MAP[square]){\n                var peer = SQUARE_PEERS_MAP[square][pi];\n\n                var candidates_new =\n                        sudoku._eliminate(candidates, peer, target_val);\n\n                if(!candidates_new){\n                    return false;\n                }\n            }\n\n        // Otherwise, if the square has no candidates, we have a contradiction.\n        // Return false.\n        } if(nr_candidates === 0){\n            return false;\n        }\n\n        // If a unit is reduced to only one place for a value, then assign it\n        for(var ui in SQUARE_UNITS_MAP[square]){\n            var unit = SQUARE_UNITS_MAP[square][ui];\n\n            var val_places = [];\n            for(var si in unit){\n                var unit_square = unit[si];\n                if(sudoku._in(val, candidates[unit_square])){\n                    val_places.push(unit_square);\n                }\n            }\n\n            // If there's no place for this value, we have a contradition!\n            // return false\n            if(val_places.length === 0){\n                return false;\n\n            // Otherwise the value can only be in one place. Assign it there.\n            } else if(val_places.length === 1){\n                candidates_new =\n                    sudoku._assign(candidates, val_places[0], val);\n\n                if(!candidates_new){\n                    return false;\n                }\n            }\n        }\n\n        return candidates;\n    };\n\n\n    // Square relationships\n    // -------------------------------------------------------------------------\n    // Squares, and their relationships with values, units, and peers.\n\n    sudoku._get_square_vals_map = function(board){\n        /* Return a map of squares -> values\n        */\n        var squares_vals_map = {};\n\n        // Make sure `board` is a string of length 81\n        if(board.length !== SQUARES.length){\n            // eslint-disable-next-line\n            throw \"Board/squares length mismatch.\";\n\n        } else {\n            for(var i in SQUARES){\n                squares_vals_map[SQUARES[i]] = board[i];\n            }\n        }\n\n        return squares_vals_map;\n    };\n\n    sudoku._get_square_units_map = function(squares, units){\n        /* Return a map of `squares` and their associated units (row, col, box)\n        */\n        var square_unit_map = {};\n\n        // For every square...\n        for(var si in squares){\n            var cur_square = squares[si];\n\n            // Maintain a list of the current square's units\n            var cur_square_units = [];\n\n            // Look through the units, and see if the current square is in it,\n            // and if so, add it to the list of of the square's units.\n            for(var ui in units){\n                var cur_unit = units[ui];\n\n                if(cur_unit.indexOf(cur_square) !== -1){\n                    cur_square_units.push(cur_unit);\n                }\n            }\n\n            // Save the current square and its units to the map\n            square_unit_map[cur_square] = cur_square_units;\n        }\n\n        return square_unit_map;\n    };\n\n    sudoku._get_square_peers_map = function(squares, units_map){\n        /* Return a map of `squares` and their associated peers, i.e., a set of\n        other squares in the square's unit.\n        */\n        var square_peers_map = {};\n\n        // For every square...\n        for(var si in squares){\n            var cur_square = squares[si];\n            var cur_square_units = units_map[cur_square];\n\n            // Maintain list of the current square's peers\n            var cur_square_peers = [];\n\n            // Look through the current square's units map...\n            for(var sui in cur_square_units){\n                var cur_unit = cur_square_units[sui];\n\n                for(var ui in cur_unit){\n                    var cur_unit_square = cur_unit[ui];\n\n                    if(cur_square_peers.indexOf(cur_unit_square) === -1 &&\n                            cur_unit_square !== cur_square){\n                        cur_square_peers.push(cur_unit_square);\n                    }\n                }\n            }\n\n            // Save the current square an its associated peers to the map\n            square_peers_map[cur_square] = cur_square_peers;\n        }\n\n        return square_peers_map;\n    };\n\n    sudoku._get_all_units = function(rows, cols){\n        /* Return a list of all units (rows, cols, boxes)\n        */\n        var units = [];\n\n        // Rows\n        for(var ri in rows){\n            units.push(sudoku._cross(rows[ri], cols));\n        }\n\n        // Columns\n        for(var ci in cols){\n           units.push(sudoku._cross(rows, cols[ci]));\n        }\n\n        // Boxes\n        var row_squares = [\"ABC\", \"DEF\", \"GHI\"];\n        var col_squares = [\"123\", \"456\", \"789\"];\n        for(var rsi in row_squares){\n            for(var csi in col_squares){\n                units.push(sudoku._cross(row_squares[rsi], col_squares[csi]));\n            }\n        }\n\n        return units;\n    };\n\n\n    // Conversions\n    // -------------------------------------------------------------------------\n    sudoku.board_string_to_grid = function(board_string){\n        /* Convert a board string to a two-dimensional array\n        */\n        var rows = [];\n        var cur_row = [];\n        for(var i in board_string){\n            cur_row.push(board_string[i]);\n            if(i % 9 === 8){\n                rows.push(cur_row);\n                cur_row = [];\n            }\n        }\n        return rows;\n    };\n\n    sudoku.board_grid_to_string = function(board_grid){\n        /* Convert a board grid to a string\n        */\n        var board_string = \"\";\n        for(var r = 0; r < 9; ++r){\n            for(var c = 0; c < 9; ++c){\n                board_string += board_grid[r][c];\n            }\n        }\n        return board_string;\n    };\n\n\n    // Utility\n    // -------------------------------------------------------------------------\n\n    sudoku.print_board = function(board){\n        /* Print a sudoku `board` to the console.\n        */\n\n        // Assure a valid board\n        var report = sudoku.validate_board(board);\n        if(report !== true){\n            throw report;\n        }\n\n        var V_PADDING = \" \";  // Insert after each square\n        var H_PADDING = '\\n'; // Insert after each row\n\n        var V_BOX_PADDING = \"  \"; // Box vertical padding\n        var H_BOX_PADDING = '\\n'; // Box horizontal padding\n\n        var display_string = \"\";\n\n        for(var i in board){\n            var square = board[i];\n\n            // Add the square and some padding\n            display_string += square + V_PADDING;\n\n            // Vertical edge of a box, insert v. box padding\n            if(i % 3 === 2){\n                display_string += V_BOX_PADDING;\n            }\n\n            // End of a line, insert horiz. padding\n            if(i % 9 === 8){\n                display_string += H_PADDING;\n            }\n\n            // Horizontal edge of a box, insert h. box padding\n            if(i % 27 === 26){\n                display_string += H_BOX_PADDING;\n            }\n        }\n\n        console.log(display_string);\n    };\n\n    sudoku.validate_board = function(board){\n        /* Return if the given `board` is valid or not. If it's valid, return\n        true. If it's not, return a string of the reason why it's not.\n        */\n\n        // Check for empty board\n        if(!board){\n            return \"Empty board\";\n        }\n\n        // Invalid board length\n        if(board.length !== NR_SQUARES){\n            return \"Invalid board size. Board must be exactly \" + NR_SQUARES +\n                    \" squares.\";\n        }\n\n        // Check for invalid characters\n        for(var i in board){\n            if(!sudoku._in(board[i], sudoku.DIGITS) && board[i] !== sudoku.BLANK_CHAR){\n                return \"Invalid board character encountered at index \" + i +\n                        \": \" + board[i];\n            }\n        }\n\n        // Otherwise, we're good. Return true.\n        return true;\n    };\n\n    sudoku._cross = function(a, b){\n        /* Cross product of all elements in `a` and `b`, e.g.,\n        sudoku._cross(\"abc\", \"123\") ->\n        [\"a1\", \"a2\", \"a3\", \"b1\", \"b2\", \"b3\", \"c1\", \"c2\", \"c3\"]\n        */\n        var result = [];\n        for(var ai in a){\n            for(var bi in b){\n                result.push(a[ai] + b[bi]);\n            }\n        }\n        return result;\n    };\n\n    sudoku._in = function(v, seq){\n        /* Return if a value `v` is in sequence `seq`.\n        */\n        return seq.indexOf(v) !== -1;\n    };\n\n    sudoku._first_true = function(seq){\n        /* Return the first element in `seq` that is true. If no element is\n        true, return false.\n        */\n        for(var i in seq){\n            if(seq[i]){\n                return seq[i];\n            }\n        }\n        return false;\n    };\n\n    sudoku._shuffle = function(seq){\n        /* Return a shuffled version of `seq`\n        */\n\n        // Create an array of the same size as `seq` filled with false\n        var shuffled = [];\n        for(var i = 0; i < seq.length; ++i){\n            shuffled.push(false);\n        }\n\n        for(i in seq){\n            var ti = sudoku._rand_range(seq.length);\n\n            while(shuffled[ti]){\n                ti = (ti + 1) > (seq.length - 1) ? 0 : (ti + 1);\n            }\n\n            shuffled[ti] = seq[i];\n        }\n\n        return shuffled;\n    };\n\n    sudoku._rand_range = function(max, min){\n        /* Get a random integer in the range of `min` to `max` (non inclusive).\n        If `min` not defined, default to 0. If `max` not defined, throw an\n        error.\n        */\n        min = min || 0;\n        if(max){\n            return Math.floor(Math.random() * (max - min)) + min;\n        } else {\n            // eslint-disable-next-line\n            throw \"Range undefined\";\n        }\n    };\n\n    sudoku._strip_dups = function(seq){\n        /* Strip duplicate values from `seq`\n        */\n        var seq_set = [];\n        var dup_map = {};\n        for(var i in seq){\n            var e = seq[i];\n            if(!dup_map[e]){\n                seq_set.push(e);\n                dup_map[e] = true;\n            }\n        }\n        return seq_set;\n    };\n\n    sudoku._force_range = function(nr, max, min){\n        /* Force `nr` to be within the range from `min` to, but not including,\n        `max`. `min` is optional, and will default to 0. If `nr` is undefined,\n        treat it as zero.\n        */\n        min = min || 0\n        nr = nr || 0\n        if(nr < min){\n            return min;\n        }\n        if(nr > max){\n            return max;\n        }\n        return nr\n    }\n\n    // Initialize library after load\n    initialize();\n\n    export const getSudoku = () => {\n      return sudoku;\n    }\n\n// Pass whatever the root object is, like 'window' in browsers\n//})(this);\n"]},"metadata":{},"sourceType":"module"}