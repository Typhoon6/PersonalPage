{"ast":null,"code":"var _toConsumableArray = require(\"C:\\\\Users\\\\admin\\\\Downloads\\\\Future\\\\personal-project\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\toConsumableArray.js\").default;\n\nvar _slicedToArray = require(\"C:\\\\Users\\\\admin\\\\Downloads\\\\Future\\\\personal-project\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\slicedToArray.js\").default;\n\nvar _toArray = require(\"C:\\\\Users\\\\admin\\\\Downloads\\\\Future\\\\personal-project\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\toArray.js\").default;\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\admin\\\\Downloads\\\\Future\\\\personal-project\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\classCallCheck.js\").default;\n\nvar _createClass = require(\"C:\\\\Users\\\\admin\\\\Downloads\\\\Future\\\\personal-project\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\createClass.js\").default;\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\admin\\\\Downloads\\\\Future\\\\personal-project\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\possibleConstructorReturn.js\").default;\n\nvar _assertThisInitialized = require(\"C:\\\\Users\\\\admin\\\\Downloads\\\\Future\\\\personal-project\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\assertThisInitialized.js\").default;\n\nvar _inherits = require(\"C:\\\\Users\\\\admin\\\\Downloads\\\\Future\\\\personal-project\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\inherits.js\").default;\n\nvar _createSuper = require(\"C:\\\\Users\\\\admin\\\\Downloads\\\\Future\\\\personal-project\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\createSuper.js\").default;\n\n/*\n * node-cache 5.1.2 ( 2020-07-01 )\n * https://github.com/node-cache/node-cache\n *\n * Released under the MIT license\n * https://github.com/node-cache/node-cache/blob/master/LICENSE\n *\n * Maintained by  (  )\n*/\n(function () {\n  var EventEmitter,\n      NodeCache,\n      clone,\n      splice = [].splice,\n      boundMethodCheck = function boundMethodCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new Error('Bound instance method accessed before binding');\n    }\n  },\n      indexOf = [].indexOf;\n\n  clone = require(\"clone\");\n  EventEmitter = require('events').EventEmitter; // generate superclass\n\n  module.exports = NodeCache = function () {\n    var NodeCache = /*#__PURE__*/function (_EventEmitter) {\n      \"use strict\";\n\n      _inherits(NodeCache, _EventEmitter);\n\n      var _super = _createSuper(NodeCache);\n\n      function NodeCache() {\n        var _this;\n\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, NodeCache);\n\n        _this = _super.call(this); // ## get\n        // get a cached key and change the stats\n        // **Parameters:**\n        // * `key` ( String | Number ): cache key\n        // **Example:**\n        //\tmyCache.get \"myKey\", ( err, val )\n\n        _this.get = _this.get.bind(_assertThisInitialized(_this)); // ## mget\n        // get multiple cached keys at once and change the stats\n        // **Parameters:**\n        // * `keys` ( String|Number[] ): an array of keys\n        // **Example:**\n        //\tmyCache.mget [ \"foo\", \"bar\" ]\n\n        _this.mget = _this.mget.bind(_assertThisInitialized(_this)); // ## set\n        // set a cached key and change the stats\n        // **Parameters:**\n        // * `key` ( String | Number ): cache key\n        // * `value` ( Any ): A element to cache. If the option `option.forceString` is `true` the module trys to translate it to a serialized JSON\n        // * `[ ttl ]` ( Number | String ): ( optional ) The time to live in seconds.\n        // **Example:**\n        //\tmyCache.set \"myKey\", \"my_String Value\"\n        //\tmyCache.set \"myKey\", \"my_String Value\", 10\n\n        _this.set = _this.set.bind(_assertThisInitialized(_this)); // ## mset\n        // set multiple keys at once\n        // **Parameters:**\n        // * `keyValueSet` ( Object[] ): an array of object which includes key,value and ttl\n        // **Example:**\n        //\tmyCache.mset(\n        //\t\t[\n        //\t\t\t{\n        //\t\t\t\tkey: \"myKey\",\n        //\t\t\t\tval: \"myValue\",\n        //\t\t\t\tttl: [ttl in seconds]\n        //\t\t\t}\n        //\t\t])\n\n        _this.mset = _this.mset.bind(_assertThisInitialized(_this)); // ## del\n        // remove keys\n        // **Parameters:**\n        // * `keys` ( String |Â Number | String|Number[] ): cache key to delete or a array of cache keys\n        // **Return**\n        // ( Number ): Number of deleted keys\n        // **Example:**\n        //\tmyCache.del( \"myKey\" )\n\n        _this.del = _this.del.bind(_assertThisInitialized(_this)); // ## take\n        // get the cached value and remove the key from the cache.\n        // Equivalent to calling `get(key)` + `del(key)`.\n        // Useful for implementing `single use` mechanism such as OTP, where once a value is read it will become obsolete.\n        // **Parameters:**\n        // * `key` ( String | Number ): cache key\n        // **Example:**\n        //\tmyCache.take \"myKey\", ( err, val )\n\n        _this.take = _this.take.bind(_assertThisInitialized(_this)); // ## ttl\n        // reset or redefine the ttl of a key. `ttl` = 0 means infinite lifetime.\n        // If `ttl` is not passed the default ttl is used.\n        // If `ttl` < 0 the key will be deleted.\n        // **Parameters:**\n        // * `key` ( String | Number ): cache key to reset the ttl value\n        // * `ttl` ( Number ): ( optional -> options.stdTTL || 0 ) The time to live in seconds\n        // **Return**\n        // ( Boolen ): key found and ttl set\n        // **Example:**\n        //\tmyCache.ttl( \"myKey\" ) // will set ttl to default ttl\n        //\tmyCache.ttl( \"myKey\", 1000 )\n\n        _this.ttl = _this.ttl.bind(_assertThisInitialized(_this)); // ## getTtl\n        // receive the ttl of a key.\n        // **Parameters:**\n        // * `key` ( String | Number ): cache key to check the ttl value\n        // **Return**\n        // ( Number|undefined ): The timestamp in ms when the key will expire, 0 if it will never expire or undefined if it not exists\n        // **Example:**\n        //\tmyCache.getTtl( \"myKey\" )\n\n        _this.getTtl = _this.getTtl.bind(_assertThisInitialized(_this)); // ## keys\n        // list all keys within this cache\n        // **Return**\n        // ( Array ): An array of all keys\n        // **Example:**\n        //     _keys = myCache.keys()\n        //     # [ \"foo\", \"bar\", \"fizz\", \"buzz\", \"anotherKeys\" ]\n\n        _this.keys = _this.keys.bind(_assertThisInitialized(_this)); // ## has\n        // Check if a key is cached\n        // **Parameters:**\n        // * `key` ( String | Number ): cache key to check the ttl value\n        // **Return**\n        // ( Boolean ): A boolean that indicates if the key is cached\n        // **Example:**\n        //     _exists = myCache.has('myKey')\n        //     # true\n\n        _this.has = _this.has.bind(_assertThisInitialized(_this)); // ## getStats\n        // get the stats\n        // **Parameters:**\n        // -\n        // **Return**\n        // ( Object ): Stats data\n        // **Example:**\n        //     myCache.getStats()\n        //     # {\n        //     # hits: 0,\n        //     # misses: 0,\n        //     # keys: 0,\n        //     # ksize: 0,\n        //     # vsize: 0\n        //     # }\n\n        _this.getStats = _this.getStats.bind(_assertThisInitialized(_this)); // ## flushAll\n        // flush the whole data and reset the stats\n        // **Example:**\n        //     myCache.flushAll()\n        //     myCache.getStats()\n        //     # {\n        //     # hits: 0,\n        //     # misses: 0,\n        //     # keys: 0,\n        //     # ksize: 0,\n        //     # vsize: 0\n        //     # }\n\n        _this.flushAll = _this.flushAll.bind(_assertThisInitialized(_this)); // ## flushStats\n        // flush the stats and reset all counters to 0\n        // **Example:**\n        //     myCache.flushStats()\n        //     myCache.getStats()\n        //     # {\n        //     # hits: 0,\n        //     # misses: 0,\n        //     # keys: 0,\n        //     # ksize: 0,\n        //     # vsize: 0\n        //     # }\n\n        _this.flushStats = _this.flushStats.bind(_assertThisInitialized(_this)); // ## close\n        // This will clear the interval timeout which is set on checkperiod option.\n        // **Example:**\n        //     myCache.close()\n\n        _this.close = _this.close.bind(_assertThisInitialized(_this)); // ## _checkData\n        // internal housekeeping method.\n        // Check all the cached data and delete the invalid values\n\n        _this._checkData = _this._checkData.bind(_assertThisInitialized(_this)); // ## _check\n        // internal method the check the value. If it's not valid any more delete it\n\n        _this._check = _this._check.bind(_assertThisInitialized(_this)); // ## _isInvalidKey\n        // internal method to check if the type of a key is either `number` or `string`\n\n        _this._isInvalidKey = _this._isInvalidKey.bind(_assertThisInitialized(_this)); // ## _wrap\n        // internal method to wrap a value in an object with some metadata\n\n        _this._wrap = _this._wrap.bind(_assertThisInitialized(_this)); // ## _getValLength\n        // internal method to calculate the value length\n\n        _this._getValLength = _this._getValLength.bind(_assertThisInitialized(_this)); // ## _error\n        // internal method to handle an error message\n\n        _this._error = _this._error.bind(_assertThisInitialized(_this)); // ## _initErrors\n        // internal method to generate error message templates\n\n        _this._initErrors = _this._initErrors.bind(_assertThisInitialized(_this));\n        _this.options = options;\n\n        _this._initErrors(); // container for cached data\n\n\n        _this.data = {}; // module options\n\n        _this.options = Object.assign({\n          // convert all elements to string\n          forceString: false,\n          // used standard size for calculating value size\n          objectValueSize: 80,\n          promiseValueSize: 80,\n          arrayValueSize: 40,\n          // standard time to live in seconds. 0 = infinity;\n          stdTTL: 0,\n          // time in seconds to check all data and delete expired keys\n          checkperiod: 600,\n          // en/disable cloning of variables. If `true` you'll get a copy of the cached variable. If `false` you'll save and get just the reference\n          useClones: true,\n          // whether values should be deleted automatically at expiration\n          deleteOnExpire: true,\n          // enable legacy callbacks\n          enableLegacyCallbacks: false,\n          // max amount of keys that are being stored\n          maxKeys: -1\n        }, _this.options); // generate functions with callbacks (legacy)\n\n        if (_this.options.enableLegacyCallbacks) {\n          console.warn(\"WARNING! node-cache legacy callback support will drop in v6.x\");\n          [\"get\", \"mget\", \"set\", \"del\", \"ttl\", \"getTtl\", \"keys\", \"has\"].forEach(function (methodKey) {\n            var oldMethod; // reference real function\n\n            oldMethod = _this[methodKey];\n\n            _this[methodKey] = function () {\n              var _ref, _ref2, _splice$call, _splice$call2;\n\n              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n              }\n\n              var cb, err, ref, res;\n              ref = args, (_ref = ref, _ref2 = _toArray(_ref), args = _ref2.slice(0), _ref), (_splice$call = splice.call(args, -1), _splice$call2 = _slicedToArray(_splice$call, 1), cb = _splice$call2[0], _splice$call); // return a callback if cb is defined and a function\n\n              if (typeof cb === \"function\") {\n                try {\n                  res = oldMethod.apply(void 0, _toConsumableArray(args));\n                  cb(null, res);\n                } catch (error1) {\n                  err = error1;\n                  cb(err);\n                }\n              } else {\n                return oldMethod.apply(void 0, _toConsumableArray(args).concat([cb]));\n              }\n            };\n          });\n        } // statistics container\n\n\n        _this.stats = {\n          hits: 0,\n          misses: 0,\n          keys: 0,\n          ksize: 0,\n          vsize: 0\n        }; // pre allocate valid keytypes array\n\n        _this.validKeyTypes = [\"string\", \"number\"]; // initalize checking period\n\n        _this._checkData();\n\n        return _possibleConstructorReturn(_this);\n      }\n\n      _createClass(NodeCache, [{\n        key: \"get\",\n        value: function get(key) {\n          var _ret, err;\n\n          boundMethodCheck(this, NodeCache); // handle invalid key types\n\n          if ((err = this._isInvalidKey(key)) != null) {\n            throw err;\n          } // get data and incremet stats\n\n\n          if (this.data[key] != null && this._check(key, this.data[key])) {\n            this.stats.hits++;\n            _ret = this._unwrap(this.data[key]); // return data\n\n            return _ret;\n          } else {\n            // if not found return undefined\n            this.stats.misses++;\n            return void 0;\n          }\n        }\n      }, {\n        key: \"mget\",\n        value: function mget(keys) {\n          var _err, err, i, key, len, oRet;\n\n          boundMethodCheck(this, NodeCache); // convert a string to an array of one key\n\n          if (!Array.isArray(keys)) {\n            _err = this._error(\"EKEYSTYPE\");\n            throw _err;\n          } // define return\n\n\n          oRet = {};\n\n          for (i = 0, len = keys.length; i < len; i++) {\n            key = keys[i]; // handle invalid key types\n\n            if ((err = this._isInvalidKey(key)) != null) {\n              throw err;\n            } // get data and increment stats\n\n\n            if (this.data[key] != null && this._check(key, this.data[key])) {\n              this.stats.hits++;\n              oRet[key] = this._unwrap(this.data[key]);\n            } else {\n              // if not found return a error\n              this.stats.misses++;\n            }\n          } // return all found keys\n\n\n          return oRet;\n        }\n      }, {\n        key: \"set\",\n        value: function set(key, value, ttl) {\n          var _err, err, existent;\n\n          boundMethodCheck(this, NodeCache); // check if cache is overflowing\n\n          if (this.options.maxKeys > -1 && this.stats.keys >= this.options.maxKeys) {\n            _err = this._error(\"ECACHEFULL\");\n            throw _err;\n          } // force the data to string\n\n\n          if (this.options.forceString && !typeof value === \"string\") {\n            value = JSON.stringify(value);\n          } // set default ttl if not passed\n\n\n          if (ttl == null) {\n            ttl = this.options.stdTTL;\n          } // handle invalid key types\n\n\n          if ((err = this._isInvalidKey(key)) != null) {\n            throw err;\n          } // internal helper variables\n\n\n          existent = false; // remove existing data from stats\n\n          if (this.data[key]) {\n            existent = true;\n            this.stats.vsize -= this._getValLength(this._unwrap(this.data[key], false));\n          } // set the value\n\n\n          this.data[key] = this._wrap(value, ttl);\n          this.stats.vsize += this._getValLength(value); // only add the keys and key-size if the key is new\n\n          if (!existent) {\n            this.stats.ksize += this._getKeyLength(key);\n            this.stats.keys++;\n          }\n\n          this.emit(\"set\", key, value); // return true\n\n          return true;\n        }\n      }, {\n        key: \"mset\",\n        value: function mset(keyValueSet) {\n          var _err, err, i, j, key, keyValuePair, len, len1, ttl, val;\n\n          boundMethodCheck(this, NodeCache); // check if cache is overflowing\n\n          if (this.options.maxKeys > -1 && this.stats.keys + keyValueSet.length >= this.options.maxKeys) {\n            _err = this._error(\"ECACHEFULL\");\n            throw _err;\n          } // loop over keyValueSet to validate key and ttl\n\n\n          for (i = 0, len = keyValueSet.length; i < len; i++) {\n            keyValuePair = keyValueSet[i];\n            var _keyValuePair = keyValuePair;\n            key = _keyValuePair.key;\n            val = _keyValuePair.val;\n            ttl = _keyValuePair.ttl;\n\n            // check if there is ttl and it's a number\n            if (ttl && typeof ttl !== \"number\") {\n              _err = this._error(\"ETTLTYPE\");\n              throw _err;\n            } // handle invalid key types\n\n\n            if ((err = this._isInvalidKey(key)) != null) {\n              throw err;\n            }\n          }\n\n          for (j = 0, len1 = keyValueSet.length; j < len1; j++) {\n            keyValuePair = keyValueSet[j];\n            var _keyValuePair2 = keyValuePair;\n            key = _keyValuePair2.key;\n            val = _keyValuePair2.val;\n            ttl = _keyValuePair2.ttl;\n            this.set(key, val, ttl);\n          }\n\n          return true;\n        }\n      }, {\n        key: \"del\",\n        value: function del(keys) {\n          var delCount, err, i, key, len, oldVal;\n          boundMethodCheck(this, NodeCache); // convert keys to an array of itself\n\n          if (!Array.isArray(keys)) {\n            keys = [keys];\n          }\n\n          delCount = 0;\n\n          for (i = 0, len = keys.length; i < len; i++) {\n            key = keys[i]; // handle invalid key types\n\n            if ((err = this._isInvalidKey(key)) != null) {\n              throw err;\n            } // only delete if existent\n\n\n            if (this.data[key] != null) {\n              // calc the stats\n              this.stats.vsize -= this._getValLength(this._unwrap(this.data[key], false));\n              this.stats.ksize -= this._getKeyLength(key);\n              this.stats.keys--;\n              delCount++; // delete the value\n\n              oldVal = this.data[key];\n              delete this.data[key]; // return true\n\n              this.emit(\"del\", key, oldVal.v);\n            }\n          }\n\n          return delCount;\n        }\n      }, {\n        key: \"take\",\n        value: function take(key) {\n          var _ret;\n\n          boundMethodCheck(this, NodeCache);\n          _ret = this.get(key);\n\n          if (_ret != null) {\n            this.del(key);\n          }\n\n          return _ret;\n        }\n      }, {\n        key: \"ttl\",\n        value: function ttl(key, _ttl2) {\n          var err;\n          boundMethodCheck(this, NodeCache);\n          _ttl2 || (_ttl2 = this.options.stdTTL);\n\n          if (!key) {\n            return false;\n          } // handle invalid key types\n\n\n          if ((err = this._isInvalidKey(key)) != null) {\n            throw err;\n          } // check for existent data and update the ttl value\n\n\n          if (this.data[key] != null && this._check(key, this.data[key])) {\n            // if ttl < 0 delete the key. otherwise reset the value\n            if (_ttl2 >= 0) {\n              this.data[key] = this._wrap(this.data[key].v, _ttl2, false);\n            } else {\n              this.del(key);\n            }\n\n            return true;\n          } else {\n            // return false if key has not been found\n            return false;\n          }\n        }\n      }, {\n        key: \"getTtl\",\n        value: function getTtl(key) {\n          var _ttl, err;\n\n          boundMethodCheck(this, NodeCache);\n\n          if (!key) {\n            return void 0;\n          } // handle invalid key types\n\n\n          if ((err = this._isInvalidKey(key)) != null) {\n            throw err;\n          } // check for existant data and update the ttl value\n\n\n          if (this.data[key] != null && this._check(key, this.data[key])) {\n            _ttl = this.data[key].t;\n            return _ttl;\n          } else {\n            // return undefined if key has not been found\n            return void 0;\n          }\n        }\n      }, {\n        key: \"keys\",\n        value: function keys() {\n          var _keys;\n\n          boundMethodCheck(this, NodeCache);\n          _keys = Object.keys(this.data);\n          return _keys;\n        }\n      }, {\n        key: \"has\",\n        value: function has(key) {\n          var _exists;\n\n          boundMethodCheck(this, NodeCache);\n          _exists = this.data[key] != null && this._check(key, this.data[key]);\n          return _exists;\n        }\n      }, {\n        key: \"getStats\",\n        value: function getStats() {\n          boundMethodCheck(this, NodeCache);\n          return this.stats;\n        }\n      }, {\n        key: \"flushAll\",\n        value: function flushAll() {\n          var _startPeriod = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n          boundMethodCheck(this, NodeCache); // parameter just for testing\n          // set data empty\n\n          this.data = {}; // reset stats\n\n          this.stats = {\n            hits: 0,\n            misses: 0,\n            keys: 0,\n            ksize: 0,\n            vsize: 0\n          }; // reset check period\n\n          this._killCheckPeriod();\n\n          this._checkData(_startPeriod);\n\n          this.emit(\"flush\");\n        }\n      }, {\n        key: \"flushStats\",\n        value: function flushStats() {\n          boundMethodCheck(this, NodeCache); // reset stats\n\n          this.stats = {\n            hits: 0,\n            misses: 0,\n            keys: 0,\n            ksize: 0,\n            vsize: 0\n          };\n          this.emit(\"flush_stats\");\n        }\n      }, {\n        key: \"close\",\n        value: function close() {\n          boundMethodCheck(this, NodeCache);\n\n          this._killCheckPeriod();\n        }\n      }, {\n        key: \"_checkData\",\n        value: function _checkData() {\n          var startPeriod = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n          var key, ref, value;\n          boundMethodCheck(this, NodeCache);\n          ref = this.data; // run the housekeeping method\n\n          for (key in ref) {\n            value = ref[key];\n\n            this._check(key, value);\n          }\n\n          if (startPeriod && this.options.checkperiod > 0) {\n            this.checkTimeout = setTimeout(this._checkData, this.options.checkperiod * 1000, startPeriod);\n\n            if (this.checkTimeout != null && this.checkTimeout.unref != null) {\n              this.checkTimeout.unref();\n            }\n          }\n        } // ## _killCheckPeriod\n        // stop the checkdata period. Only needed to abort the script in testing mode.\n\n      }, {\n        key: \"_killCheckPeriod\",\n        value: function _killCheckPeriod() {\n          if (this.checkTimeout != null) {\n            return clearTimeout(this.checkTimeout);\n          }\n        }\n      }, {\n        key: \"_check\",\n        value: function _check(key, data) {\n          var _retval;\n\n          boundMethodCheck(this, NodeCache);\n          _retval = true; // data is invalid if the ttl is too old and is not 0\n          // console.log data.t < Date.now(), data.t, Date.now()\n\n          if (data.t !== 0 && data.t < Date.now()) {\n            if (this.options.deleteOnExpire) {\n              _retval = false;\n              this.del(key);\n            }\n\n            this.emit(\"expired\", key, this._unwrap(data));\n          }\n\n          return _retval;\n        }\n      }, {\n        key: \"_isInvalidKey\",\n        value: function _isInvalidKey(key) {\n          var ref;\n          boundMethodCheck(this, NodeCache);\n\n          if (ref = typeof key, indexOf.call(this.validKeyTypes, ref) < 0) {\n            return this._error(\"EKEYTYPE\", {\n              type: typeof key\n            });\n          }\n        }\n      }, {\n        key: \"_wrap\",\n        value: function _wrap(value, ttl) {\n          var asClone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n          var livetime, now, oReturn, ttlMultiplicator;\n          boundMethodCheck(this, NodeCache);\n\n          if (!this.options.useClones) {\n            asClone = false;\n          } // define the time to live\n\n\n          now = Date.now();\n          livetime = 0;\n          ttlMultiplicator = 1000; // use given ttl\n\n          if (ttl === 0) {\n            livetime = 0;\n          } else if (ttl) {\n            livetime = now + ttl * ttlMultiplicator;\n          } else {\n            // use standard ttl\n            if (this.options.stdTTL === 0) {\n              livetime = this.options.stdTTL;\n            } else {\n              livetime = now + this.options.stdTTL * ttlMultiplicator;\n            }\n          } // return the wrapped value\n\n\n          return oReturn = {\n            t: livetime,\n            v: asClone ? clone(value) : value\n          };\n        } // ## _unwrap\n        // internal method to extract get the value out of the wrapped value\n\n      }, {\n        key: \"_unwrap\",\n        value: function _unwrap(value) {\n          var asClone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n          if (!this.options.useClones) {\n            asClone = false;\n          }\n\n          if (value.v != null) {\n            if (asClone) {\n              return clone(value.v);\n            } else {\n              return value.v;\n            }\n          }\n\n          return null;\n        } // ## _getKeyLength\n        // internal method the calculate the key length\n\n      }, {\n        key: \"_getKeyLength\",\n        value: function _getKeyLength(key) {\n          return key.toString().length;\n        }\n      }, {\n        key: \"_getValLength\",\n        value: function _getValLength(value) {\n          boundMethodCheck(this, NodeCache);\n\n          if (typeof value === \"string\") {\n            // if the value is a String get the real length\n            return value.length;\n          } else if (this.options.forceString) {\n            // force string if it's defined and not passed\n            return JSON.stringify(value).length;\n          } else if (Array.isArray(value)) {\n            // if the data is an Array multiply each element with a defined default length\n            return this.options.arrayValueSize * value.length;\n          } else if (typeof value === \"number\") {\n            return 8;\n          } else if (typeof (value != null ? value.then : void 0) === \"function\") {\n            // if the data is a Promise, use defined default\n            // (can't calculate actual/resolved value size synchronously)\n            return this.options.promiseValueSize;\n          } else if (typeof Buffer !== \"undefined\" && Buffer !== null ? Buffer.isBuffer(value) : void 0) {\n            return value.length;\n          } else if (value != null && typeof value === \"object\") {\n            // if the data is an Object multiply each element with a defined default length\n            return this.options.objectValueSize * Object.keys(value).length;\n          } else if (typeof value === \"boolean\") {\n            return 8;\n          } else {\n            // default fallback\n            return 0;\n          }\n        }\n      }, {\n        key: \"_error\",\n        value: function _error(type) {\n          var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n          var error;\n          boundMethodCheck(this, NodeCache); // generate the error object\n\n          error = new Error();\n          error.name = type;\n          error.errorcode = type;\n          error.message = this.ERRORS[type] != null ? this.ERRORS[type](data) : \"-\";\n          error.data = data; // return the error object\n\n          return error;\n        }\n      }, {\n        key: \"_initErrors\",\n        value: function _initErrors() {\n          var _errMsg, _errT, ref;\n\n          boundMethodCheck(this, NodeCache);\n          this.ERRORS = {};\n          ref = this._ERRORS;\n\n          for (_errT in ref) {\n            _errMsg = ref[_errT];\n            this.ERRORS[_errT] = this.createErrorMessage(_errMsg);\n          }\n        }\n      }, {\n        key: \"createErrorMessage\",\n        value: function createErrorMessage(errMsg) {\n          return function (args) {\n            return errMsg.replace(\"__key\", args.type);\n          };\n        }\n      }]);\n\n      return NodeCache;\n    }(EventEmitter);\n\n    ;\n    NodeCache.prototype._ERRORS = {\n      \"ENOTFOUND\": \"Key `__key` not found\",\n      \"ECACHEFULL\": \"Cache max keys amount exceeded\",\n      \"EKEYTYPE\": \"The key argument has to be of type `string` or `number`. Found: `__key`\",\n      \"EKEYSTYPE\": \"The keys argument has to be an array.\",\n      \"ETTLTYPE\": \"The ttl argument has to be a number.\"\n    };\n    return NodeCache;\n  }.call(this);\n}).call(this);","map":{"version":3,"sources":["C:/Users/admin/Downloads/Future/personal-project/node_modules/node-cache/lib/node_cache.js"],"names":["EventEmitter","NodeCache","clone","splice","boundMethodCheck","instance","Constructor","Error","indexOf","require","module","exports","options","get","bind","mget","set","mset","del","take","ttl","getTtl","keys","has","getStats","flushAll","flushStats","close","_checkData","_check","_isInvalidKey","_wrap","_getValLength","_error","_initErrors","data","Object","assign","forceString","objectValueSize","promiseValueSize","arrayValueSize","stdTTL","checkperiod","useClones","deleteOnExpire","enableLegacyCallbacks","maxKeys","console","warn","forEach","methodKey","oldMethod","args","cb","err","ref","res","call","error1","stats","hits","misses","ksize","vsize","validKeyTypes","key","_ret","_unwrap","_err","i","len","oRet","Array","isArray","length","value","existent","JSON","stringify","_getKeyLength","emit","keyValueSet","j","keyValuePair","len1","val","delCount","oldVal","v","_ttl","t","_keys","_exists","_startPeriod","_killCheckPeriod","startPeriod","checkTimeout","setTimeout","unref","clearTimeout","_retval","Date","now","type","asClone","livetime","oReturn","ttlMultiplicator","toString","then","Buffer","isBuffer","error","name","errorcode","message","ERRORS","_errMsg","_errT","_ERRORS","createErrorMessage","errMsg","replace","prototype"],"mappings":"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","sourcesContent":["/*\n * node-cache 5.1.2 ( 2020-07-01 )\n * https://github.com/node-cache/node-cache\n *\n * Released under the MIT license\n * https://github.com/node-cache/node-cache/blob/master/LICENSE\n *\n * Maintained by  (  )\n*/\n(function() {\n  var EventEmitter, NodeCache, clone,\n    splice = [].splice,\n    boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } },\n    indexOf = [].indexOf;\n\n  clone = require(\"clone\");\n\n  EventEmitter = require('events').EventEmitter;\n\n  // generate superclass\n  module.exports = NodeCache = (function() {\n    class NodeCache extends EventEmitter {\n      constructor(options = {}) {\n        super();\n        // ## get\n\n        // get a cached key and change the stats\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key\n\n        // **Example:**\n\n        //\tmyCache.get \"myKey\", ( err, val )\n\n        this.get = this.get.bind(this);\n        // ## mget\n\n        // get multiple cached keys at once and change the stats\n\n        // **Parameters:**\n\n        // * `keys` ( String|Number[] ): an array of keys\n\n        // **Example:**\n\n        //\tmyCache.mget [ \"foo\", \"bar\" ]\n\n        this.mget = this.mget.bind(this);\n        // ## set\n\n        // set a cached key and change the stats\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key\n        // * `value` ( Any ): A element to cache. If the option `option.forceString` is `true` the module trys to translate it to a serialized JSON\n        // * `[ ttl ]` ( Number | String ): ( optional ) The time to live in seconds.\n\n        // **Example:**\n\n        //\tmyCache.set \"myKey\", \"my_String Value\"\n\n        //\tmyCache.set \"myKey\", \"my_String Value\", 10\n\n        this.set = this.set.bind(this);\n        \n        // ## mset\n\n        // set multiple keys at once\n\n        // **Parameters:**\n\n        // * `keyValueSet` ( Object[] ): an array of object which includes key,value and ttl\n\n        // **Example:**\n\n        //\tmyCache.mset(\n        //\t\t[\n        //\t\t\t{\n        //\t\t\t\tkey: \"myKey\",\n        //\t\t\t\tval: \"myValue\",\n        //\t\t\t\tttl: [ttl in seconds]\n        //\t\t\t}\n        //\t\t])\n\n        this.mset = this.mset.bind(this);\n        // ## del\n\n        // remove keys\n\n        // **Parameters:**\n\n        // * `keys` ( String |Â Number | String|Number[] ): cache key to delete or a array of cache keys\n\n        // **Return**\n\n        // ( Number ): Number of deleted keys\n\n        // **Example:**\n\n        //\tmyCache.del( \"myKey\" )\n\n        this.del = this.del.bind(this);\n        // ## take\n\n        // get the cached value and remove the key from the cache.\n        // Equivalent to calling `get(key)` + `del(key)`.\n        // Useful for implementing `single use` mechanism such as OTP, where once a value is read it will become obsolete.\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key\n\n        // **Example:**\n\n        //\tmyCache.take \"myKey\", ( err, val )\n\n        this.take = this.take.bind(this);\n        // ## ttl\n\n        // reset or redefine the ttl of a key. `ttl` = 0 means infinite lifetime.\n        // If `ttl` is not passed the default ttl is used.\n        // If `ttl` < 0 the key will be deleted.\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key to reset the ttl value\n        // * `ttl` ( Number ): ( optional -> options.stdTTL || 0 ) The time to live in seconds\n\n        // **Return**\n\n        // ( Boolen ): key found and ttl set\n\n        // **Example:**\n\n        //\tmyCache.ttl( \"myKey\" ) // will set ttl to default ttl\n\n        //\tmyCache.ttl( \"myKey\", 1000 )\n\n        this.ttl = this.ttl.bind(this);\n        // ## getTtl\n\n        // receive the ttl of a key.\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key to check the ttl value\n\n        // **Return**\n\n        // ( Number|undefined ): The timestamp in ms when the key will expire, 0 if it will never expire or undefined if it not exists\n\n        // **Example:**\n\n        //\tmyCache.getTtl( \"myKey\" )\n\n        this.getTtl = this.getTtl.bind(this);\n        // ## keys\n\n        // list all keys within this cache\n\n        // **Return**\n\n        // ( Array ): An array of all keys\n\n        // **Example:**\n\n        //     _keys = myCache.keys()\n\n        //     # [ \"foo\", \"bar\", \"fizz\", \"buzz\", \"anotherKeys\" ]\n\n        this.keys = this.keys.bind(this);\n        // ## has\n\n        // Check if a key is cached\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key to check the ttl value\n\n        // **Return**\n\n        // ( Boolean ): A boolean that indicates if the key is cached\n\n        // **Example:**\n\n        //     _exists = myCache.has('myKey')\n\n        //     # true\n\n        this.has = this.has.bind(this);\n        // ## getStats\n\n        // get the stats\n\n        // **Parameters:**\n\n        // -\n\n        // **Return**\n\n        // ( Object ): Stats data\n\n        // **Example:**\n\n        //     myCache.getStats()\n        //     # {\n        //     # hits: 0,\n        //     # misses: 0,\n        //     # keys: 0,\n        //     # ksize: 0,\n        //     # vsize: 0\n        //     # }\n\n        this.getStats = this.getStats.bind(this);\n        // ## flushAll\n\n        // flush the whole data and reset the stats\n\n        // **Example:**\n\n        //     myCache.flushAll()\n\n        //     myCache.getStats()\n        //     # {\n        //     # hits: 0,\n        //     # misses: 0,\n        //     # keys: 0,\n        //     # ksize: 0,\n        //     # vsize: 0\n        //     # }\n\n        this.flushAll = this.flushAll.bind(this);\n        \n        // ## flushStats\n\n        // flush the stats and reset all counters to 0\n\n        // **Example:**\n\n        //     myCache.flushStats()\n\n        //     myCache.getStats()\n        //     # {\n        //     # hits: 0,\n        //     # misses: 0,\n        //     # keys: 0,\n        //     # ksize: 0,\n        //     # vsize: 0\n        //     # }\n\n        this.flushStats = this.flushStats.bind(this);\n        // ## close\n\n        // This will clear the interval timeout which is set on checkperiod option.\n\n        // **Example:**\n\n        //     myCache.close()\n\n        this.close = this.close.bind(this);\n        // ## _checkData\n\n        // internal housekeeping method.\n        // Check all the cached data and delete the invalid values\n        this._checkData = this._checkData.bind(this);\n        // ## _check\n\n        // internal method the check the value. If it's not valid any more delete it\n        this._check = this._check.bind(this);\n        // ## _isInvalidKey\n\n        // internal method to check if the type of a key is either `number` or `string`\n        this._isInvalidKey = this._isInvalidKey.bind(this);\n        // ## _wrap\n\n        // internal method to wrap a value in an object with some metadata\n        this._wrap = this._wrap.bind(this);\n        // ## _getValLength\n\n        // internal method to calculate the value length\n        this._getValLength = this._getValLength.bind(this);\n        // ## _error\n\n        // internal method to handle an error message\n        this._error = this._error.bind(this);\n        // ## _initErrors\n\n        // internal method to generate error message templates\n        this._initErrors = this._initErrors.bind(this);\n        this.options = options;\n        this._initErrors();\n        // container for cached data\n        this.data = {};\n        // module options\n        this.options = Object.assign({\n          // convert all elements to string\n          forceString: false,\n          // used standard size for calculating value size\n          objectValueSize: 80,\n          promiseValueSize: 80,\n          arrayValueSize: 40,\n          // standard time to live in seconds. 0 = infinity;\n          stdTTL: 0,\n          // time in seconds to check all data and delete expired keys\n          checkperiod: 600,\n          // en/disable cloning of variables. If `true` you'll get a copy of the cached variable. If `false` you'll save and get just the reference\n          useClones: true,\n          // whether values should be deleted automatically at expiration\n          deleteOnExpire: true,\n          // enable legacy callbacks\n          enableLegacyCallbacks: false,\n          // max amount of keys that are being stored\n          maxKeys: -1\n        }, this.options);\n        // generate functions with callbacks (legacy)\n        if (this.options.enableLegacyCallbacks) {\n          console.warn(\"WARNING! node-cache legacy callback support will drop in v6.x\");\n          [\"get\", \"mget\", \"set\", \"del\", \"ttl\", \"getTtl\", \"keys\", \"has\"].forEach((methodKey) => {\n            var oldMethod;\n            // reference real function\n            oldMethod = this[methodKey];\n            this[methodKey] = function(...args) {\n              var cb, err, ref, res;\n              ref = args, [...args] = ref, [cb] = splice.call(args, -1);\n              // return a callback if cb is defined and a function\n              if (typeof cb === \"function\") {\n                try {\n                  res = oldMethod(...args);\n                  cb(null, res);\n                } catch (error1) {\n                  err = error1;\n                  cb(err);\n                }\n              } else {\n                return oldMethod(...args, cb);\n              }\n            };\n          });\n        }\n        // statistics container\n        this.stats = {\n          hits: 0,\n          misses: 0,\n          keys: 0,\n          ksize: 0,\n          vsize: 0\n        };\n        // pre allocate valid keytypes array\n        this.validKeyTypes = [\"string\", \"number\"];\n        // initalize checking period\n        this._checkData();\n        return;\n      }\n\n      get(key) {\n        var _ret, err;\n        boundMethodCheck(this, NodeCache);\n        // handle invalid key types\n        if ((err = this._isInvalidKey(key)) != null) {\n          throw err;\n        }\n        // get data and incremet stats\n        if ((this.data[key] != null) && this._check(key, this.data[key])) {\n          this.stats.hits++;\n          _ret = this._unwrap(this.data[key]);\n          // return data\n          return _ret;\n        } else {\n          // if not found return undefined\n          this.stats.misses++;\n          return void 0;\n        }\n      }\n\n      mget(keys) {\n        var _err, err, i, key, len, oRet;\n        boundMethodCheck(this, NodeCache);\n        // convert a string to an array of one key\n        if (!Array.isArray(keys)) {\n          _err = this._error(\"EKEYSTYPE\");\n          throw _err;\n        }\n        // define return\n        oRet = {};\n        for (i = 0, len = keys.length; i < len; i++) {\n          key = keys[i];\n          // handle invalid key types\n          if ((err = this._isInvalidKey(key)) != null) {\n            throw err;\n          }\n          // get data and increment stats\n          if ((this.data[key] != null) && this._check(key, this.data[key])) {\n            this.stats.hits++;\n            oRet[key] = this._unwrap(this.data[key]);\n          } else {\n            // if not found return a error\n            this.stats.misses++;\n          }\n        }\n        // return all found keys\n        return oRet;\n      }\n\n      set(key, value, ttl) {\n        var _err, err, existent;\n        boundMethodCheck(this, NodeCache);\n        // check if cache is overflowing\n        if (this.options.maxKeys > -1 && this.stats.keys >= this.options.maxKeys) {\n          _err = this._error(\"ECACHEFULL\");\n          throw _err;\n        }\n        // force the data to string\n        if (this.options.forceString && !typeof value === \"string\") {\n          value = JSON.stringify(value);\n        }\n        // set default ttl if not passed\n        if (ttl == null) {\n          ttl = this.options.stdTTL;\n        }\n        // handle invalid key types\n        if ((err = this._isInvalidKey(key)) != null) {\n          throw err;\n        }\n        // internal helper variables\n        existent = false;\n        // remove existing data from stats\n        if (this.data[key]) {\n          existent = true;\n          this.stats.vsize -= this._getValLength(this._unwrap(this.data[key], false));\n        }\n        // set the value\n        this.data[key] = this._wrap(value, ttl);\n        this.stats.vsize += this._getValLength(value);\n        // only add the keys and key-size if the key is new\n        if (!existent) {\n          this.stats.ksize += this._getKeyLength(key);\n          this.stats.keys++;\n        }\n        this.emit(\"set\", key, value);\n        // return true\n        return true;\n      }\n\n      mset(keyValueSet) {\n        var _err, err, i, j, key, keyValuePair, len, len1, ttl, val;\n        boundMethodCheck(this, NodeCache);\n        // check if cache is overflowing\n        if (this.options.maxKeys > -1 && this.stats.keys + keyValueSet.length >= this.options.maxKeys) {\n          _err = this._error(\"ECACHEFULL\");\n          throw _err;\n        }\n\n// loop over keyValueSet to validate key and ttl\n        for (i = 0, len = keyValueSet.length; i < len; i++) {\n          keyValuePair = keyValueSet[i];\n          ({key, val, ttl} = keyValuePair);\n          // check if there is ttl and it's a number\n          if (ttl && typeof ttl !== \"number\") {\n            _err = this._error(\"ETTLTYPE\");\n            throw _err;\n          }\n          // handle invalid key types\n          if ((err = this._isInvalidKey(key)) != null) {\n            throw err;\n          }\n        }\n        for (j = 0, len1 = keyValueSet.length; j < len1; j++) {\n          keyValuePair = keyValueSet[j];\n          ({key, val, ttl} = keyValuePair);\n          this.set(key, val, ttl);\n        }\n        return true;\n      }\n\n      del(keys) {\n        var delCount, err, i, key, len, oldVal;\n        boundMethodCheck(this, NodeCache);\n        // convert keys to an array of itself\n        if (!Array.isArray(keys)) {\n          keys = [keys];\n        }\n        delCount = 0;\n        for (i = 0, len = keys.length; i < len; i++) {\n          key = keys[i];\n          // handle invalid key types\n          if ((err = this._isInvalidKey(key)) != null) {\n            throw err;\n          }\n          // only delete if existent\n          if (this.data[key] != null) {\n            // calc the stats\n            this.stats.vsize -= this._getValLength(this._unwrap(this.data[key], false));\n            this.stats.ksize -= this._getKeyLength(key);\n            this.stats.keys--;\n            delCount++;\n            // delete the value\n            oldVal = this.data[key];\n            delete this.data[key];\n            // return true\n            this.emit(\"del\", key, oldVal.v);\n          }\n        }\n        return delCount;\n      }\n\n      take(key) {\n        var _ret;\n        boundMethodCheck(this, NodeCache);\n        _ret = this.get(key);\n        if ((_ret != null)) {\n          this.del(key);\n        }\n        return _ret;\n      }\n\n      ttl(key, ttl) {\n        var err;\n        boundMethodCheck(this, NodeCache);\n        ttl || (ttl = this.options.stdTTL);\n        if (!key) {\n          return false;\n        }\n        // handle invalid key types\n        if ((err = this._isInvalidKey(key)) != null) {\n          throw err;\n        }\n        // check for existent data and update the ttl value\n        if ((this.data[key] != null) && this._check(key, this.data[key])) {\n          // if ttl < 0 delete the key. otherwise reset the value\n          if (ttl >= 0) {\n            this.data[key] = this._wrap(this.data[key].v, ttl, false);\n          } else {\n            this.del(key);\n          }\n          return true;\n        } else {\n          // return false if key has not been found\n          return false;\n        }\n      }\n\n      getTtl(key) {\n        var _ttl, err;\n        boundMethodCheck(this, NodeCache);\n        if (!key) {\n          return void 0;\n        }\n        // handle invalid key types\n        if ((err = this._isInvalidKey(key)) != null) {\n          throw err;\n        }\n        // check for existant data and update the ttl value\n        if ((this.data[key] != null) && this._check(key, this.data[key])) {\n          _ttl = this.data[key].t;\n          return _ttl;\n        } else {\n          // return undefined if key has not been found\n          return void 0;\n        }\n      }\n\n      keys() {\n        var _keys;\n        boundMethodCheck(this, NodeCache);\n        _keys = Object.keys(this.data);\n        return _keys;\n      }\n\n      has(key) {\n        var _exists;\n        boundMethodCheck(this, NodeCache);\n        _exists = (this.data[key] != null) && this._check(key, this.data[key]);\n        return _exists;\n      }\n\n      getStats() {\n        boundMethodCheck(this, NodeCache);\n        return this.stats;\n      }\n\n      flushAll(_startPeriod = true) {\n        boundMethodCheck(this, NodeCache);\n        // parameter just for testing\n\n        // set data empty\n        this.data = {};\n        // reset stats\n        this.stats = {\n          hits: 0,\n          misses: 0,\n          keys: 0,\n          ksize: 0,\n          vsize: 0\n        };\n        // reset check period\n        this._killCheckPeriod();\n        this._checkData(_startPeriod);\n        this.emit(\"flush\");\n      }\n\n      flushStats() {\n        boundMethodCheck(this, NodeCache);\n        // reset stats\n        this.stats = {\n          hits: 0,\n          misses: 0,\n          keys: 0,\n          ksize: 0,\n          vsize: 0\n        };\n        this.emit(\"flush_stats\");\n      }\n\n      close() {\n        boundMethodCheck(this, NodeCache);\n        this._killCheckPeriod();\n      }\n\n      _checkData(startPeriod = true) {\n        var key, ref, value;\n        boundMethodCheck(this, NodeCache);\n        ref = this.data;\n        // run the housekeeping method\n        for (key in ref) {\n          value = ref[key];\n          this._check(key, value);\n        }\n        if (startPeriod && this.options.checkperiod > 0) {\n          this.checkTimeout = setTimeout(this._checkData, this.options.checkperiod * 1000, startPeriod);\n          if ((this.checkTimeout != null) && (this.checkTimeout.unref != null)) {\n            this.checkTimeout.unref();\n          }\n        }\n      }\n\n      // ## _killCheckPeriod\n\n      // stop the checkdata period. Only needed to abort the script in testing mode.\n      _killCheckPeriod() {\n        if (this.checkTimeout != null) {\n          return clearTimeout(this.checkTimeout);\n        }\n      }\n\n      _check(key, data) {\n        var _retval;\n        boundMethodCheck(this, NodeCache);\n        _retval = true;\n        // data is invalid if the ttl is too old and is not 0\n        // console.log data.t < Date.now(), data.t, Date.now()\n        if (data.t !== 0 && data.t < Date.now()) {\n          if (this.options.deleteOnExpire) {\n            _retval = false;\n            this.del(key);\n          }\n          this.emit(\"expired\", key, this._unwrap(data));\n        }\n        return _retval;\n      }\n\n      _isInvalidKey(key) {\n        var ref;\n        boundMethodCheck(this, NodeCache);\n        if (ref = typeof key, indexOf.call(this.validKeyTypes, ref) < 0) {\n          return this._error(\"EKEYTYPE\", {\n            type: typeof key\n          });\n        }\n      }\n\n      _wrap(value, ttl, asClone = true) {\n        var livetime, now, oReturn, ttlMultiplicator;\n        boundMethodCheck(this, NodeCache);\n        if (!this.options.useClones) {\n          asClone = false;\n        }\n        // define the time to live\n        now = Date.now();\n        livetime = 0;\n        ttlMultiplicator = 1000;\n        // use given ttl\n        if (ttl === 0) {\n          livetime = 0;\n        } else if (ttl) {\n          livetime = now + (ttl * ttlMultiplicator);\n        } else {\n          // use standard ttl\n          if (this.options.stdTTL === 0) {\n            livetime = this.options.stdTTL;\n          } else {\n            livetime = now + (this.options.stdTTL * ttlMultiplicator);\n          }\n        }\n        // return the wrapped value\n        return oReturn = {\n          t: livetime,\n          v: asClone ? clone(value) : value\n        };\n      }\n\n      // ## _unwrap\n\n      // internal method to extract get the value out of the wrapped value\n      _unwrap(value, asClone = true) {\n        if (!this.options.useClones) {\n          asClone = false;\n        }\n        if (value.v != null) {\n          if (asClone) {\n            return clone(value.v);\n          } else {\n            return value.v;\n          }\n        }\n        return null;\n      }\n\n      // ## _getKeyLength\n\n      // internal method the calculate the key length\n      _getKeyLength(key) {\n        return key.toString().length;\n      }\n\n      _getValLength(value) {\n        boundMethodCheck(this, NodeCache);\n        if (typeof value === \"string\") {\n          // if the value is a String get the real length\n          return value.length;\n        } else if (this.options.forceString) {\n          // force string if it's defined and not passed\n          return JSON.stringify(value).length;\n        } else if (Array.isArray(value)) {\n          // if the data is an Array multiply each element with a defined default length\n          return this.options.arrayValueSize * value.length;\n        } else if (typeof value === \"number\") {\n          return 8;\n        } else if (typeof (value != null ? value.then : void 0) === \"function\") {\n          // if the data is a Promise, use defined default\n          // (can't calculate actual/resolved value size synchronously)\n          return this.options.promiseValueSize;\n        } else if (typeof Buffer !== \"undefined\" && Buffer !== null ? Buffer.isBuffer(value) : void 0) {\n          return value.length;\n        } else if ((value != null) && typeof value === \"object\") {\n          // if the data is an Object multiply each element with a defined default length\n          return this.options.objectValueSize * Object.keys(value).length;\n        } else if (typeof value === \"boolean\") {\n          return 8;\n        } else {\n          // default fallback\n          return 0;\n        }\n      }\n\n      _error(type, data = {}) {\n        var error;\n        boundMethodCheck(this, NodeCache);\n        // generate the error object\n        error = new Error();\n        error.name = type;\n        error.errorcode = type;\n        error.message = this.ERRORS[type] != null ? this.ERRORS[type](data) : \"-\";\n        error.data = data;\n        // return the error object\n        return error;\n      }\n\n      _initErrors() {\n        var _errMsg, _errT, ref;\n        boundMethodCheck(this, NodeCache);\n        this.ERRORS = {};\n        ref = this._ERRORS;\n        for (_errT in ref) {\n          _errMsg = ref[_errT];\n          this.ERRORS[_errT] = this.createErrorMessage(_errMsg);\n        }\n      }\n\n      createErrorMessage(errMsg) {\n        return function(args) {\n          return errMsg.replace(\"__key\", args.type);\n        };\n      }\n\n    };\n\n    NodeCache.prototype._ERRORS = {\n      \"ENOTFOUND\": \"Key `__key` not found\",\n      \"ECACHEFULL\": \"Cache max keys amount exceeded\",\n      \"EKEYTYPE\": \"The key argument has to be of type `string` or `number`. Found: `__key`\",\n      \"EKEYSTYPE\": \"The keys argument has to be an array.\",\n      \"ETTLTYPE\": \"The ttl argument has to be a number.\"\n    };\n\n    return NodeCache;\n\n  }).call(this);\n\n}).call(this);\n"]},"metadata":{},"sourceType":"script"}