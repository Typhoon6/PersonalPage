{"ast":null,"code":"import _slicedToArray from \"C:\\\\Users\\\\admin\\\\Downloads\\\\Future\\\\personal-project\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\slicedToArray.js\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\admin\\\\Downloads\\\\Future\\\\personal-project\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createForOfIteratorHelper.js\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\admin\\\\Downloads\\\\Future\\\\personal-project\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\nimport _regeneratorRuntime from \"C:\\\\Users\\\\admin\\\\Downloads\\\\Future\\\\personal-project\\\\node_modules\\\\@babel\\\\runtime\\\\regenerator\\\\index.js\";\nimport AggregateError from 'aggregate-error';\nexport default function pMap(_x, _x2) {\n  return _pMap.apply(this, arguments);\n}\n\nfunction _pMap() {\n  _pMap = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(iterable, mapper) {\n    var _ref,\n        _ref$concurrency,\n        concurrency,\n        _ref$stopOnError,\n        stopOnError,\n        _args4 = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _ref = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {}, _ref$concurrency = _ref.concurrency, concurrency = _ref$concurrency === void 0 ? Number.POSITIVE_INFINITY : _ref$concurrency, _ref$stopOnError = _ref.stopOnError, stopOnError = _ref$stopOnError === void 0 ? true : _ref$stopOnError;\n            return _context4.abrupt(\"return\", new Promise(function (resolve, reject_) {\n              // eslint-disable-line promise/param-names\n              if (iterable[Symbol.iterator] === undefined && iterable[Symbol.asyncIterator] === undefined) {\n                throw new TypeError(\"Expected `input` to be either an `Iterable` or `AsyncIterable`, got (\".concat(typeof iterable, \")\"));\n              }\n\n              if (typeof mapper !== 'function') {\n                throw new TypeError('Mapper function is required');\n              }\n\n              if (!((Number.isSafeInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency >= 1)) {\n                throw new TypeError(\"Expected `concurrency` to be an integer from 1 and up or `Infinity`, got `\".concat(concurrency, \"` (\").concat(typeof concurrency, \")\"));\n              }\n\n              var result = [];\n              var errors = [];\n              var skippedIndexesMap = new Map();\n              var isRejected = false;\n              var isResolved = false;\n              var isIterableDone = false;\n              var resolvingCount = 0;\n              var currentIndex = 0;\n              var iterator = iterable[Symbol.iterator] === undefined ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();\n\n              var reject = function reject(reason) {\n                isRejected = true;\n                isResolved = true;\n                reject_(reason);\n              };\n\n              var next = /*#__PURE__*/function () {\n                var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n                  var nextItem, index, pureResult, _iterator, _step, _step$value, _index, value;\n\n                  return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                    while (1) {\n                      switch (_context2.prev = _context2.next) {\n                        case 0:\n                          if (!isResolved) {\n                            _context2.next = 2;\n                            break;\n                          }\n\n                          return _context2.abrupt(\"return\");\n\n                        case 2:\n                          _context2.next = 4;\n                          return iterator.next();\n\n                        case 4:\n                          nextItem = _context2.sent;\n                          index = currentIndex;\n                          currentIndex++; // Note: `iterator.next()` can be called many times in parallel.\n                          // This can cause multiple calls to this `next()` function to\n                          // receive a `nextItem` with `done === true`.\n                          // The shutdown logic that rejects/resolves must be protected\n                          // so it runs only one time as the `skippedIndex` logic is\n                          // non-idempotent.\n\n                          if (!nextItem.done) {\n                            _context2.next = 38;\n                            break;\n                          }\n\n                          isIterableDone = true;\n\n                          if (!(resolvingCount === 0 && !isResolved)) {\n                            _context2.next = 37;\n                            break;\n                          }\n\n                          if (!(!stopOnError && errors.length > 0)) {\n                            _context2.next = 13;\n                            break;\n                          }\n\n                          reject(new AggregateError(errors));\n                          return _context2.abrupt(\"return\");\n\n                        case 13:\n                          isResolved = true;\n\n                          if (skippedIndexesMap.size) {\n                            _context2.next = 17;\n                            break;\n                          }\n\n                          resolve(result);\n                          return _context2.abrupt(\"return\");\n\n                        case 17:\n                          pureResult = []; // Support multiple `pMapSkip`'s.\n\n                          // Support multiple `pMapSkip`'s.\n                          _iterator = _createForOfIteratorHelper(result.entries());\n                          _context2.prev = 19;\n\n                          _iterator.s();\n\n                        case 21:\n                          if ((_step = _iterator.n()).done) {\n                            _context2.next = 28;\n                            break;\n                          }\n\n                          _step$value = _slicedToArray(_step.value, 2), _index = _step$value[0], value = _step$value[1];\n\n                          if (!(skippedIndexesMap.get(_index) === pMapSkip)) {\n                            _context2.next = 25;\n                            break;\n                          }\n\n                          return _context2.abrupt(\"continue\", 26);\n\n                        case 25:\n                          pureResult.push(value);\n\n                        case 26:\n                          _context2.next = 21;\n                          break;\n\n                        case 28:\n                          _context2.next = 33;\n                          break;\n\n                        case 30:\n                          _context2.prev = 30;\n                          _context2.t0 = _context2[\"catch\"](19);\n\n                          _iterator.e(_context2.t0);\n\n                        case 33:\n                          _context2.prev = 33;\n\n                          _iterator.f();\n\n                          return _context2.finish(33);\n\n                        case 36:\n                          resolve(pureResult);\n\n                        case 37:\n                          return _context2.abrupt(\"return\");\n\n                        case 38:\n                          resolvingCount++; // Intentionally detached\n\n                          // Intentionally detached\n                          _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n                            var element, _value;\n\n                            return _regeneratorRuntime.wrap(function _callee$(_context) {\n                              while (1) {\n                                switch (_context.prev = _context.next) {\n                                  case 0:\n                                    _context.prev = 0;\n                                    _context.next = 3;\n                                    return nextItem.value;\n\n                                  case 3:\n                                    element = _context.sent;\n\n                                    if (!isResolved) {\n                                      _context.next = 6;\n                                      break;\n                                    }\n\n                                    return _context.abrupt(\"return\");\n\n                                  case 6:\n                                    _context.next = 8;\n                                    return mapper(element, index);\n\n                                  case 8:\n                                    _value = _context.sent;\n\n                                    // Use Map to stage the index of the element.\n                                    if (_value === pMapSkip) {\n                                      skippedIndexesMap.set(index, _value);\n                                    }\n\n                                    result[index] = _value;\n                                    resolvingCount--;\n                                    _context.next = 14;\n                                    return next();\n\n                                  case 14:\n                                    _context.next = 32;\n                                    break;\n\n                                  case 16:\n                                    _context.prev = 16;\n                                    _context.t0 = _context[\"catch\"](0);\n\n                                    if (!stopOnError) {\n                                      _context.next = 22;\n                                      break;\n                                    }\n\n                                    reject(_context.t0);\n                                    _context.next = 32;\n                                    break;\n\n                                  case 22:\n                                    errors.push(_context.t0);\n                                    resolvingCount--; // In that case we can't really continue regardless of `stopOnError` state\n                                    // since an iterable is likely to continue throwing after it throws once.\n                                    // If we continue calling `next()` indefinitely we will likely end up\n                                    // in an infinite loop of failed iteration.\n\n                                    _context.prev = 24;\n                                    _context.next = 27;\n                                    return next();\n\n                                  case 27:\n                                    _context.next = 32;\n                                    break;\n\n                                  case 29:\n                                    _context.prev = 29;\n                                    _context.t1 = _context[\"catch\"](24);\n                                    reject(_context.t1);\n\n                                  case 32:\n                                  case \"end\":\n                                    return _context.stop();\n                                }\n                              }\n                            }, _callee, null, [[0, 16], [24, 29]]);\n                          }))();\n\n                        case 40:\n                        case \"end\":\n                          return _context2.stop();\n                      }\n                    }\n                  }, _callee2, null, [[19, 30, 33, 36]]);\n                }));\n\n                return function next() {\n                  return _ref2.apply(this, arguments);\n                };\n              }(); // Create the concurrent runners in a detached (non-awaited)\n              // promise. We need this so we can await the `next()` calls\n              // to stop creating runners before hitting the concurrency limit\n              // if the iterable has already been marked as done.\n              // NOTE: We *must* do this for async iterators otherwise we'll spin up\n              // infinite `next()` calls by default and never start the event loop.\n\n\n              // Create the concurrent runners in a detached (non-awaited)\n              // promise. We need this so we can await the `next()` calls\n              // to stop creating runners before hitting the concurrency limit\n              // if the iterable has already been marked as done.\n              // NOTE: We *must* do this for async iterators otherwise we'll spin up\n              // infinite `next()` calls by default and never start the event loop.\n              _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n                var index;\n                return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                  while (1) {\n                    switch (_context3.prev = _context3.next) {\n                      case 0:\n                        index = 0;\n\n                      case 1:\n                        if (!(index < concurrency)) {\n                          _context3.next = 16;\n                          break;\n                        }\n\n                        _context3.prev = 2;\n                        _context3.next = 5;\n                        return next();\n\n                      case 5:\n                        _context3.next = 11;\n                        break;\n\n                      case 7:\n                        _context3.prev = 7;\n                        _context3.t0 = _context3[\"catch\"](2);\n                        reject(_context3.t0);\n                        return _context3.abrupt(\"break\", 16);\n\n                      case 11:\n                        if (!(isIterableDone || isRejected)) {\n                          _context3.next = 13;\n                          break;\n                        }\n\n                        return _context3.abrupt(\"break\", 16);\n\n                      case 13:\n                        index++;\n                        _context3.next = 1;\n                        break;\n\n                      case 16:\n                      case \"end\":\n                        return _context3.stop();\n                    }\n                  }\n                }, _callee3, null, [[2, 7]]);\n              }))();\n            }));\n\n          case 2:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _pMap.apply(this, arguments);\n}\n\nexport var pMapSkip = Symbol('skip');","map":{"version":3,"sources":["C:/Users/admin/Downloads/Future/personal-project/node_modules/pokedex-promise-v2/node_modules/p-map/index.js"],"names":["AggregateError","pMap","iterable","mapper","concurrency","Number","POSITIVE_INFINITY","stopOnError","Promise","resolve","reject_","Symbol","iterator","undefined","asyncIterator","TypeError","isSafeInteger","result","errors","skippedIndexesMap","Map","isRejected","isResolved","isIterableDone","resolvingCount","currentIndex","reject","reason","next","nextItem","index","done","length","size","pureResult","entries","value","get","pMapSkip","push","element","set"],"mappings":"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","sourcesContent":["import AggregateError from 'aggregate-error';\n\nexport default async function pMap(\n\titerable,\n\tmapper,\n\t{\n\t\tconcurrency = Number.POSITIVE_INFINITY,\n\t\tstopOnError = true\n\t} = {}\n) {\n\treturn new Promise((resolve, reject_) => { // eslint-disable-line promise/param-names\n\t\tif (iterable[Symbol.iterator] === undefined && iterable[Symbol.asyncIterator] === undefined) {\n\t\t\tthrow new TypeError(`Expected \\`input\\` to be either an \\`Iterable\\` or \\`AsyncIterable\\`, got (${typeof iterable})`);\n\t\t}\n\n\t\tif (typeof mapper !== 'function') {\n\t\t\tthrow new TypeError('Mapper function is required');\n\t\t}\n\n\t\tif (!((Number.isSafeInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency >= 1)) {\n\t\t\tthrow new TypeError(`Expected \\`concurrency\\` to be an integer from 1 and up or \\`Infinity\\`, got \\`${concurrency}\\` (${typeof concurrency})`);\n\t\t}\n\n\t\tconst result = [];\n\t\tconst errors = [];\n\t\tconst skippedIndexesMap = new Map();\n\t\tlet isRejected = false;\n\t\tlet isResolved = false;\n\t\tlet isIterableDone = false;\n\t\tlet resolvingCount = 0;\n\t\tlet currentIndex = 0;\n\t\tconst iterator = iterable[Symbol.iterator] === undefined ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();\n\n\t\tconst reject = reason => {\n\t\t\tisRejected = true;\n\t\t\tisResolved = true;\n\t\t\treject_(reason);\n\t\t};\n\n\t\tconst next = async () => {\n\t\t\tif (isResolved) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst nextItem = await iterator.next();\n\n\t\t\tconst index = currentIndex;\n\t\t\tcurrentIndex++;\n\n\t\t\t// Note: `iterator.next()` can be called many times in parallel.\n\t\t\t// This can cause multiple calls to this `next()` function to\n\t\t\t// receive a `nextItem` with `done === true`.\n\t\t\t// The shutdown logic that rejects/resolves must be protected\n\t\t\t// so it runs only one time as the `skippedIndex` logic is\n\t\t\t// non-idempotent.\n\t\t\tif (nextItem.done) {\n\t\t\t\tisIterableDone = true;\n\n\t\t\t\tif (resolvingCount === 0 && !isResolved) {\n\t\t\t\t\tif (!stopOnError && errors.length > 0) {\n\t\t\t\t\t\treject(new AggregateError(errors));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tisResolved = true;\n\n\t\t\t\t\tif (!skippedIndexesMap.size) {\n\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst pureResult = [];\n\n\t\t\t\t\t// Support multiple `pMapSkip`'s.\n\t\t\t\t\tfor (const [index, value] of result.entries()) {\n\t\t\t\t\t\tif (skippedIndexesMap.get(index) === pMapSkip) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpureResult.push(value);\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve(pureResult);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresolvingCount++;\n\n\t\t\t// Intentionally detached\n\t\t\t(async () => {\n\t\t\t\ttry {\n\t\t\t\t\tconst element = await nextItem.value;\n\n\t\t\t\t\tif (isResolved) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst value = await mapper(element, index);\n\n\t\t\t\t\t// Use Map to stage the index of the element.\n\t\t\t\t\tif (value === pMapSkip) {\n\t\t\t\t\t\tskippedIndexesMap.set(index, value);\n\t\t\t\t\t}\n\n\t\t\t\t\tresult[index] = value;\n\n\t\t\t\t\tresolvingCount--;\n\t\t\t\t\tawait next();\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (stopOnError) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t} else {\n\t\t\t\t\t\terrors.push(error);\n\t\t\t\t\t\tresolvingCount--;\n\n\t\t\t\t\t\t// In that case we can't really continue regardless of `stopOnError` state\n\t\t\t\t\t\t// since an iterable is likely to continue throwing after it throws once.\n\t\t\t\t\t\t// If we continue calling `next()` indefinitely we will likely end up\n\t\t\t\t\t\t// in an infinite loop of failed iteration.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait next();\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})();\n\t\t};\n\n\t\t// Create the concurrent runners in a detached (non-awaited)\n\t\t// promise. We need this so we can await the `next()` calls\n\t\t// to stop creating runners before hitting the concurrency limit\n\t\t// if the iterable has already been marked as done.\n\t\t// NOTE: We *must* do this for async iterators otherwise we'll spin up\n\t\t// infinite `next()` calls by default and never start the event loop.\n\t\t(async () => {\n\t\t\tfor (let index = 0; index < concurrency; index++) {\n\t\t\t\ttry {\n\t\t\t\t\t// eslint-disable-next-line no-await-in-loop\n\t\t\t\t\tawait next();\n\t\t\t\t} catch (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (isIterableDone || isRejected) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t})();\n\t});\n}\n\nexport const pMapSkip = Symbol('skip');\n"]},"metadata":{},"sourceType":"module"}