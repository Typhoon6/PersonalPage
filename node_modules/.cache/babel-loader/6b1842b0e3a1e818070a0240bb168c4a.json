{"ast":null,"code":"/*\n    Sudoku.js\n    ---------\n\n    A Sudoku puzzle generator and solver JavaScript library.\n\n    Please see the README for more details.\n*/\n//(function(root){\n//var sudoku = root.sudoku = {};  // Global reference to the sudoku library\nvar sudoku = {};\nsudoku.DIGITS = \"123456789\"; // Allowed sudoku.DIGITS\n\nvar ROWS = \"ABCDEFGHI\"; // Row lables\n\nvar COLS = sudoku.DIGITS; // Column lables\n\nvar SQUARES = null; // Square IDs\n\nvar UNITS = null; // All units (row, column, or box)\n\nvar SQUARE_UNITS_MAP = null; // Squares -> units map\n\nvar SQUARE_PEERS_MAP = null; // Squares -> peers map\n\nvar MIN_GIVENS = 17; // Minimum number of givens\n\nvar NR_SQUARES = 81; // Number of squares\n// Define difficulties by how many squares are given to the player in a new\n// puzzle.\n\nvar DIFFICULTY = {\n  \"easy\": 62,\n  \"medium\": 53,\n  \"hard\": 44,\n  \"very-hard\": 35,\n  \"insane\": 26,\n  \"inhuman\": 17\n}; // Blank character and board representation\n\nsudoku.BLANK_CHAR = '.';\nsudoku.BLANK_BOARD = \"....................................................\" + \".............................\"; // Init\n// -------------------------------------------------------------------------\n\nfunction initialize() {\n  /* Initialize the Sudoku library (invoked after library load)\n  */\n  SQUARES = sudoku._cross(ROWS, COLS);\n  UNITS = sudoku._get_all_units(ROWS, COLS);\n  SQUARE_UNITS_MAP = sudoku._get_square_units_map(SQUARES, UNITS);\n  SQUARE_PEERS_MAP = sudoku._get_square_peers_map(SQUARES, SQUARE_UNITS_MAP);\n} // Generate\n// -------------------------------------------------------------------------\n\n\nsudoku.generate = function (difficulty, unique) {\n  /* Generate a new Sudoku puzzle of a particular `difficulty`, e.g.,\n       // Generate an \"easy\" sudoku puzzle\n      sudoku.generate(\"easy\");\n    Difficulties are as follows, and represent the number of given squares:\n           \"easy\":         61\n          \"medium\":       52\n          \"hard\":         43\n          \"very-hard\":    34\n          \"insane\":       25\n          \"inhuman\":      17\n    You may also enter a custom number of squares to be given, e.g.,\n       // Generate a new Sudoku puzzle with 60 given squares\n      sudoku.generate(60)\n    `difficulty` must be a number between 17 and 81 inclusive. If it's\n  outside of that range, `difficulty` will be set to the closest bound,\n  e.g., 0 -> 17, and 100 -> 81.\n    By default, the puzzles are unique, uless you set `unique` to false.\n  (Note: Puzzle uniqueness is not yet implemented, so puzzles are *not*\n  guaranteed to have unique solutions)\n   TODO: Implement puzzle uniqueness\n  */\n  // If `difficulty` is a string or undefined, convert it to a number or\n  // default it to \"easy\" if undefined.\n  if (typeof difficulty === \"string\" || typeof difficulty === \"undefined\") {\n    difficulty = DIFFICULTY[difficulty] || DIFFICULTY.easy;\n  } // Force difficulty between 17 and 81 inclusive\n\n\n  difficulty = sudoku._force_range(difficulty, NR_SQUARES + 1, MIN_GIVENS); // Default unique to true\n\n  unique = unique || true; // Get a set of squares and all possible candidates for each square\n\n  var blank_board = \"\";\n\n  for (var i = 0; i < NR_SQUARES; ++i) {\n    blank_board += '.';\n  }\n\n  var candidates = sudoku._get_candidates_map(blank_board); // For each item in a shuffled list of squares\n\n\n  var shuffled_squares = sudoku._shuffle(SQUARES);\n\n  for (var si in shuffled_squares) {\n    var square = shuffled_squares[si]; // If an assignment of a random chioce causes a contradictoin, give\n    // up and try again\n\n    var rand_candidate_idx = sudoku._rand_range(candidates[square].length);\n\n    var rand_candidate = candidates[square][rand_candidate_idx];\n\n    if (!sudoku._assign(candidates, square, rand_candidate)) {\n      break;\n    } // Make a list of all single candidates\n\n\n    var single_candidates = [];\n\n    for (si in SQUARES) {\n      square = SQUARES[si];\n\n      if (candidates[square].length === 1) {\n        single_candidates.push(candidates[square]);\n      }\n    } // If we have at least difficulty, and the unique candidate count is\n    // at least 8, return the puzzle!\n\n\n    if (single_candidates.length >= difficulty && sudoku._strip_dups(single_candidates).length >= 8) {\n      var board = \"\";\n      var givens_idxs = [];\n\n      for (i in SQUARES) {\n        square = SQUARES[i];\n\n        if (candidates[square].length === 1) {\n          board += candidates[square];\n          givens_idxs.push(i);\n        } else {\n          board += sudoku.BLANK_CHAR;\n        }\n      } // If we have more than `difficulty` givens, remove some random\n      // givens until we're down to exactly `difficulty`\n\n\n      var nr_givens = givens_idxs.length;\n\n      if (nr_givens > difficulty) {\n        givens_idxs = sudoku._shuffle(givens_idxs);\n\n        for (i = 0; i < nr_givens - difficulty; ++i) {\n          var target = parseInt(givens_idxs[i]);\n          board = board.substr(0, target) + sudoku.BLANK_CHAR + board.substr(target + 1);\n        }\n      } // Double check board is solvable\n      // TODO: Make a standalone board checker. Solve is expensive.\n\n\n      if (sudoku.solve(board)) {\n        return board;\n      }\n    }\n  } // Give up and try a new puzzle\n\n\n  return sudoku.generate(difficulty);\n}; // Solve\n// -------------------------------------------------------------------------\n\n\nsudoku.solve = function (board, reverse) {\n  /* Solve a sudoku puzzle given a sudoku `board`, i.e., an 81-character\n  string of sudoku.DIGITS, 1-9, and spaces identified by '.', representing the\n  squares. There must be a minimum of 17 givens. If the given board has no\n  solutions, return false.\n   Optionally set `reverse` to solve \"backwards\", i.e., rotate through the\n  possibilities in reverse. Useful for checking if there is more than one\n  solution.\n  */\n  // Assure a valid board\n  var report = sudoku.validate_board(board);\n\n  if (report !== true) {\n    throw report;\n  } // Check number of givens is at least MIN_GIVENS\n\n\n  var nr_givens = 0;\n\n  for (var i in board) {\n    if (board[i] !== sudoku.BLANK_CHAR && sudoku._in(board[i], sudoku.DIGITS)) {\n      ++nr_givens;\n    }\n  }\n\n  if (nr_givens < MIN_GIVENS) {\n    // eslint-disable-next-line\n    throw \"Too few givens. Minimum givens is \" + MIN_GIVENS;\n  } // Default reverse to false\n\n\n  reverse = reverse || false;\n\n  var candidates = sudoku._get_candidates_map(board);\n\n  var result = sudoku._search(candidates, reverse);\n\n  if (result) {\n    var solution = \"\";\n\n    for (var square in result) {\n      solution += result[square];\n    }\n\n    return solution;\n  }\n\n  return false;\n};\n\nsudoku.get_candidates = function (board) {\n  /* Return all possible candidatees for each square as a grid of\n  candidates, returnning `false` if a contradiction is encountered.\n   Really just a wrapper for sudoku._get_candidates_map for programmer\n  consumption.\n  */\n  // Assure a valid board\n  var report = sudoku.validate_board(board);\n\n  if (report !== true) {\n    throw report;\n  } // Get a candidates map\n\n\n  var candidates_map = sudoku._get_candidates_map(board); // If there's an error, return false\n\n\n  if (!candidates_map) {\n    return false;\n  } // Transform candidates map into grid\n\n\n  var rows = [];\n  var cur_row = [];\n  var i = 0;\n\n  for (var square in candidates_map) {\n    var candidates = candidates_map[square];\n    cur_row.push(candidates);\n\n    if (i % 9 === 8) {\n      rows.push(cur_row);\n      cur_row = [];\n    }\n\n    ++i;\n  }\n\n  return rows;\n};\n\nsudoku._get_candidates_map = function (board) {\n  /* Get all possible candidates for each square as a map in the form\n  {square: sudoku.DIGITS} using recursive constraint propagation. Return `false`\n  if a contradiction is encountered\n  */\n  // Assure a valid board\n  var report = sudoku.validate_board(board);\n\n  if (report !== true) {\n    throw report;\n  }\n\n  var candidate_map = {};\n\n  var squares_values_map = sudoku._get_square_vals_map(board); // Start by assigning every digit as a candidate to every square\n\n\n  for (var si in SQUARES) {\n    candidate_map[SQUARES[si]] = sudoku.DIGITS;\n  } // For each non-blank square, assign its value in the candidate map and\n  // propigate.\n\n\n  for (var square in squares_values_map) {\n    var val = squares_values_map[square];\n\n    if (sudoku._in(val, sudoku.DIGITS)) {\n      var new_candidates = sudoku._assign(candidate_map, square, val); // Fail if we can't assign val to square\n\n\n      if (!new_candidates) {\n        return false;\n      }\n    }\n  }\n\n  return candidate_map;\n};\n\nsudoku._search = function (candidates, reverse) {\n  /* Given a map of squares -> candiates, using depth-first search,\n  recursively try all possible values until a solution is found, or false\n  if no solution exists.\n  */\n  // Return if error in previous iteration\n  if (!candidates) {\n    return false;\n  } // Default reverse to false\n\n\n  reverse = reverse || false; // If only one candidate for every square, we've a solved puzzle!\n  // Return the candidates map.\n\n  var max_nr_candidates = 0; // eslint-disable-next-line\n\n  var max_candidates_square = null;\n\n  for (var si in SQUARES) {\n    var square = SQUARES[si];\n    var nr_candidates = candidates[square].length;\n\n    if (nr_candidates > max_nr_candidates) {\n      max_nr_candidates = nr_candidates; // eslint-disable-next-line no-unused-vars\n\n      max_candidates_square = square;\n    }\n  }\n\n  if (max_nr_candidates === 1) {\n    return candidates;\n  } // Choose the blank square with the fewest possibilities > 1\n\n\n  var min_nr_candidates = 10;\n  var min_candidates_square = null;\n\n  for (si in SQUARES) {\n    square = SQUARES[si];\n    nr_candidates = candidates[square].length;\n\n    if (nr_candidates < min_nr_candidates && nr_candidates > 1) {\n      min_nr_candidates = nr_candidates;\n      min_candidates_square = square;\n    }\n  } // Recursively search through each of the candidates of the square\n  // starting with the one with fewest candidates.\n  // Rotate through the candidates forwards\n\n\n  var min_candidates = candidates[min_candidates_square];\n\n  if (!reverse) {\n    for (var vi in min_candidates) {\n      var val = min_candidates[vi]; // TODO: Implement a non-rediculous deep copy function\n\n      var candidates_copy = JSON.parse(JSON.stringify(candidates));\n\n      var candidates_next = sudoku._search(sudoku._assign(candidates_copy, min_candidates_square, val));\n\n      if (candidates_next) {\n        return candidates_next;\n      }\n    } // Rotate through the candidates backwards\n\n  } else {\n    for (vi = min_candidates.length - 1; vi >= 0; --vi) {\n      val = min_candidates[vi]; // TODO: Implement a non-rediculous deep copy function\n\n      candidates_copy = JSON.parse(JSON.stringify(candidates));\n      candidates_next = sudoku._search(sudoku._assign(candidates_copy, min_candidates_square, val), reverse);\n\n      if (candidates_next) {\n        return candidates_next;\n      }\n    }\n  } // If we get through all combinations of the square with the fewest\n  // candidates without finding an answer, there isn't one. Return false.\n\n\n  return false;\n};\n\nsudoku._assign = function (candidates, square, val) {\n  /* Eliminate all values, *except* for `val`, from `candidates` at\n  `square` (candidates[square]), and propagate. Return the candidates map\n  when finished. If a contradiciton is found, return false.\n   WARNING: This will modify the contents of `candidates` directly.\n  */\n  // Grab a list of canidates without 'val'\n  var other_vals = candidates[square].replace(val, \"\"); // Loop through all other values and eliminate them from the candidates\n  // at the current square, and propigate. If at any point we get a\n  // contradiction, return false.\n\n  for (var ovi in other_vals) {\n    var other_val = other_vals[ovi];\n\n    var candidates_next = sudoku._eliminate(candidates, square, other_val);\n\n    if (!candidates_next) {\n      //console.log(\"Contradiction found by _eliminate.\");\n      return false;\n    }\n  }\n\n  return candidates;\n};\n\nsudoku._eliminate = function (candidates, square, val) {\n  /* Eliminate `val` from `candidates` at `square`, (candidates[square]),\n  and propagate when values or places <= 2. Return updated candidates,\n  unless a contradiction is detected, in which case, return false.\n   WARNING: This will modify the contents of `candidates` directly.\n  */\n  // If `val` has already been eliminated from candidates[square], return\n  // with candidates.\n  if (!sudoku._in(val, candidates[square])) {\n    return candidates;\n  } // Remove `val` from candidates[square]\n\n\n  candidates[square] = candidates[square].replace(val, ''); // If the square has only candidate left, eliminate that value from its\n  // peers\n\n  var nr_candidates = candidates[square].length;\n\n  if (nr_candidates === 1) {\n    var target_val = candidates[square];\n\n    for (var pi in SQUARE_PEERS_MAP[square]) {\n      var peer = SQUARE_PEERS_MAP[square][pi];\n\n      var candidates_new = sudoku._eliminate(candidates, peer, target_val);\n\n      if (!candidates_new) {\n        return false;\n      }\n    } // Otherwise, if the square has no candidates, we have a contradiction.\n    // Return false.\n\n  }\n\n  if (nr_candidates === 0) {\n    return false;\n  } // If a unit is reduced to only one place for a value, then assign it\n\n\n  for (var ui in SQUARE_UNITS_MAP[square]) {\n    var unit = SQUARE_UNITS_MAP[square][ui];\n    var val_places = [];\n\n    for (var si in unit) {\n      var unit_square = unit[si];\n\n      if (sudoku._in(val, candidates[unit_square])) {\n        val_places.push(unit_square);\n      }\n    } // If there's no place for this value, we have a contradition!\n    // return false\n\n\n    if (val_places.length === 0) {\n      return false; // Otherwise the value can only be in one place. Assign it there.\n    } else if (val_places.length === 1) {\n      candidates_new = sudoku._assign(candidates, val_places[0], val);\n\n      if (!candidates_new) {\n        return false;\n      }\n    }\n  }\n\n  return candidates;\n}; // Square relationships\n// -------------------------------------------------------------------------\n// Squares, and their relationships with values, units, and peers.\n\n\nsudoku._get_square_vals_map = function (board) {\n  /* Return a map of squares -> values\n  */\n  var squares_vals_map = {}; // Make sure `board` is a string of length 81\n\n  if (board.length !== SQUARES.length) {\n    // eslint-disable-next-line\n    throw \"Board/squares length mismatch.\";\n  } else {\n    for (var i in SQUARES) {\n      squares_vals_map[SQUARES[i]] = board[i];\n    }\n  }\n\n  return squares_vals_map;\n};\n\nsudoku._get_square_units_map = function (squares, units) {\n  /* Return a map of `squares` and their associated units (row, col, box)\n  */\n  var square_unit_map = {}; // For every square...\n\n  for (var si in squares) {\n    var cur_square = squares[si]; // Maintain a list of the current square's units\n\n    var cur_square_units = []; // Look through the units, and see if the current square is in it,\n    // and if so, add it to the list of of the square's units.\n\n    for (var ui in units) {\n      var cur_unit = units[ui];\n\n      if (cur_unit.indexOf(cur_square) !== -1) {\n        cur_square_units.push(cur_unit);\n      }\n    } // Save the current square and its units to the map\n\n\n    square_unit_map[cur_square] = cur_square_units;\n  }\n\n  return square_unit_map;\n};\n\nsudoku._get_square_peers_map = function (squares, units_map) {\n  /* Return a map of `squares` and their associated peers, i.e., a set of\n  other squares in the square's unit.\n  */\n  var square_peers_map = {}; // For every square...\n\n  for (var si in squares) {\n    var cur_square = squares[si];\n    var cur_square_units = units_map[cur_square]; // Maintain list of the current square's peers\n\n    var cur_square_peers = []; // Look through the current square's units map...\n\n    for (var sui in cur_square_units) {\n      var cur_unit = cur_square_units[sui];\n\n      for (var ui in cur_unit) {\n        var cur_unit_square = cur_unit[ui];\n\n        if (cur_square_peers.indexOf(cur_unit_square) === -1 && cur_unit_square !== cur_square) {\n          cur_square_peers.push(cur_unit_square);\n        }\n      }\n    } // Save the current square an its associated peers to the map\n\n\n    square_peers_map[cur_square] = cur_square_peers;\n  }\n\n  return square_peers_map;\n};\n\nsudoku._get_all_units = function (rows, cols) {\n  /* Return a list of all units (rows, cols, boxes)\n  */\n  var units = []; // Rows\n\n  for (var ri in rows) {\n    units.push(sudoku._cross(rows[ri], cols));\n  } // Columns\n\n\n  for (var ci in cols) {\n    units.push(sudoku._cross(rows, cols[ci]));\n  } // Boxes\n\n\n  var row_squares = [\"ABC\", \"DEF\", \"GHI\"];\n  var col_squares = [\"123\", \"456\", \"789\"];\n\n  for (var rsi in row_squares) {\n    for (var csi in col_squares) {\n      units.push(sudoku._cross(row_squares[rsi], col_squares[csi]));\n    }\n  }\n\n  return units;\n}; // Conversions\n// -------------------------------------------------------------------------\n\n\nsudoku.board_string_to_grid = function (board_string) {\n  /* Convert a board string to a two-dimensional array\n  */\n  var rows = [];\n  var cur_row = [];\n\n  for (var i in board_string) {\n    cur_row.push(board_string[i]);\n\n    if (i % 9 === 8) {\n      rows.push(cur_row);\n      cur_row = [];\n    }\n  }\n\n  return rows;\n};\n\nsudoku.board_grid_to_string = function (board_grid) {\n  /* Convert a board grid to a string\n  */\n  var board_string = \"\";\n\n  for (var r = 0; r < 9; ++r) {\n    for (var c = 0; c < 9; ++c) {\n      board_string += board_grid[r][c];\n    }\n  }\n\n  return board_string;\n}; // Utility\n// -------------------------------------------------------------------------\n\n\nsudoku.print_board = function (board) {\n  /* Print a sudoku `board` to the console.\n  */\n  // Assure a valid board\n  var report = sudoku.validate_board(board);\n\n  if (report !== true) {\n    throw report;\n  }\n\n  var V_PADDING = \" \"; // Insert after each square\n\n  var H_PADDING = '\\n'; // Insert after each row\n\n  var V_BOX_PADDING = \"  \"; // Box vertical padding\n\n  var H_BOX_PADDING = '\\n'; // Box horizontal padding\n\n  var display_string = \"\";\n\n  for (var i in board) {\n    var square = board[i]; // Add the square and some padding\n\n    display_string += square + V_PADDING; // Vertical edge of a box, insert v. box padding\n\n    if (i % 3 === 2) {\n      display_string += V_BOX_PADDING;\n    } // End of a line, insert horiz. padding\n\n\n    if (i % 9 === 8) {\n      display_string += H_PADDING;\n    } // Horizontal edge of a box, insert h. box padding\n\n\n    if (i % 27 === 26) {\n      display_string += H_BOX_PADDING;\n    }\n  }\n\n  console.log(display_string);\n};\n\nsudoku.validate_board = function (board) {\n  /* Return if the given `board` is valid or not. If it's valid, return\n  true. If it's not, return a string of the reason why it's not.\n  */\n  // Check for empty board\n  if (!board) {\n    return \"Empty board\";\n  } // Invalid board length\n\n\n  if (board.length !== NR_SQUARES) {\n    return \"Invalid board size. Board must be exactly \" + NR_SQUARES + \" squares.\";\n  } // Check for invalid characters\n\n\n  for (var i in board) {\n    if (!sudoku._in(board[i], sudoku.DIGITS) && board[i] !== sudoku.BLANK_CHAR) {\n      return \"Invalid board character encountered at index \" + i + \": \" + board[i];\n    }\n  } // Otherwise, we're good. Return true.\n\n\n  return true;\n};\n\nsudoku._cross = function (a, b) {\n  /* Cross product of all elements in `a` and `b`, e.g.,\n  sudoku._cross(\"abc\", \"123\") ->\n  [\"a1\", \"a2\", \"a3\", \"b1\", \"b2\", \"b3\", \"c1\", \"c2\", \"c3\"]\n  */\n  var result = [];\n\n  for (var ai in a) {\n    for (var bi in b) {\n      result.push(a[ai] + b[bi]);\n    }\n  }\n\n  return result;\n};\n\nsudoku._in = function (v, seq) {\n  /* Return if a value `v` is in sequence `seq`.\n  */\n  return seq.indexOf(v) !== -1;\n};\n\nsudoku._first_true = function (seq) {\n  /* Return the first element in `seq` that is true. If no element is\n  true, return false.\n  */\n  for (var i in seq) {\n    if (seq[i]) {\n      return seq[i];\n    }\n  }\n\n  return false;\n};\n\nsudoku._shuffle = function (seq) {\n  /* Return a shuffled version of `seq`\n  */\n  // Create an array of the same size as `seq` filled with false\n  var shuffled = [];\n\n  for (var i = 0; i < seq.length; ++i) {\n    shuffled.push(false);\n  }\n\n  for (i in seq) {\n    var ti = sudoku._rand_range(seq.length);\n\n    while (shuffled[ti]) {\n      ti = ti + 1 > seq.length - 1 ? 0 : ti + 1;\n    }\n\n    shuffled[ti] = seq[i];\n  }\n\n  return shuffled;\n};\n\nsudoku._rand_range = function (max, min) {\n  /* Get a random integer in the range of `min` to `max` (non inclusive).\n  If `min` not defined, default to 0. If `max` not defined, throw an\n  error.\n  */\n  min = min || 0;\n\n  if (max) {\n    return Math.floor(Math.random() * (max - min)) + min;\n  } else {\n    // eslint-disable-next-line\n    throw \"Range undefined\";\n  }\n};\n\nsudoku._strip_dups = function (seq) {\n  /* Strip duplicate values from `seq`\n  */\n  var seq_set = [];\n  var dup_map = {};\n\n  for (var i in seq) {\n    var e = seq[i];\n\n    if (!dup_map[e]) {\n      seq_set.push(e);\n      dup_map[e] = true;\n    }\n  }\n\n  return seq_set;\n};\n\nsudoku._force_range = function (nr, max, min) {\n  /* Force `nr` to be within the range from `min` to, but not including,\n  `max`. `min` is optional, and will default to 0. If `nr` is undefined,\n  treat it as zero.\n  */\n  min = min || 0;\n  nr = nr || 0;\n\n  if (nr < min) {\n    return min;\n  }\n\n  if (nr > max) {\n    return max;\n  }\n\n  return nr;\n}; // Initialize library after load\n\n\ninitialize();\nexport const getSudoku = () => {\n  return sudoku;\n}; // Pass whatever the root object is, like 'window' in browsers\n//})(this);","map":{"version":3,"sources":["C:/Users/admin/Downloads/Future/personal-project/src/pages/Sudoku/solver/sudoku.js"],"names":["sudoku","DIGITS","ROWS","COLS","SQUARES","UNITS","SQUARE_UNITS_MAP","SQUARE_PEERS_MAP","MIN_GIVENS","NR_SQUARES","DIFFICULTY","BLANK_CHAR","BLANK_BOARD","initialize","_cross","_get_all_units","_get_square_units_map","_get_square_peers_map","generate","difficulty","unique","easy","_force_range","blank_board","i","candidates","_get_candidates_map","shuffled_squares","_shuffle","si","square","rand_candidate_idx","_rand_range","length","rand_candidate","_assign","single_candidates","push","_strip_dups","board","givens_idxs","nr_givens","target","parseInt","substr","solve","reverse","report","validate_board","_in","result","_search","solution","get_candidates","candidates_map","rows","cur_row","candidate_map","squares_values_map","_get_square_vals_map","val","new_candidates","max_nr_candidates","max_candidates_square","nr_candidates","min_nr_candidates","min_candidates_square","min_candidates","vi","candidates_copy","JSON","parse","stringify","candidates_next","other_vals","replace","ovi","other_val","_eliminate","target_val","pi","peer","candidates_new","ui","unit","val_places","unit_square","squares_vals_map","squares","units","square_unit_map","cur_square","cur_square_units","cur_unit","indexOf","units_map","square_peers_map","cur_square_peers","sui","cur_unit_square","cols","ri","ci","row_squares","col_squares","rsi","csi","board_string_to_grid","board_string","board_grid_to_string","board_grid","r","c","print_board","V_PADDING","H_PADDING","V_BOX_PADDING","H_BOX_PADDING","display_string","console","log","a","b","ai","bi","v","seq","_first_true","shuffled","ti","max","min","Math","floor","random","seq_set","dup_map","e","nr","getSudoku"],"mappings":"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","sourcesContent":["/*\n    Sudoku.js\n    ---------\n\n    A Sudoku puzzle generator and solver JavaScript library.\n\n    Please see the README for more details.\n*/\n\n//(function(root){\n    //var sudoku = root.sudoku = {};  // Global reference to the sudoku library\n    var sudoku = {};\n    sudoku.DIGITS = \"123456789\";    // Allowed sudoku.DIGITS\n    var ROWS = \"ABCDEFGHI\";         // Row lables\n    var COLS = sudoku.DIGITS;       // Column lables\n    var SQUARES = null;             // Square IDs\n\n    var UNITS = null;               // All units (row, column, or box)\n    var SQUARE_UNITS_MAP = null;    // Squares -> units map\n    var SQUARE_PEERS_MAP = null;    // Squares -> peers map\n\n    var MIN_GIVENS = 17;            // Minimum number of givens\n    var NR_SQUARES = 81;            // Number of squares\n\n    // Define difficulties by how many squares are given to the player in a new\n    // puzzle.\n    var DIFFICULTY = {\n        \"easy\":         62,\n        \"medium\":       53,\n        \"hard\":         44,\n        \"very-hard\":    35,\n        \"insane\":       26,\n        \"inhuman\":      17,\n    };\n\n    // Blank character and board representation\n    sudoku.BLANK_CHAR = '.';\n    sudoku.BLANK_BOARD = \"....................................................\"+\n            \".............................\";\n\n    // Init\n    // -------------------------------------------------------------------------\n    function initialize(){\n        /* Initialize the Sudoku library (invoked after library load)\n        */\n        SQUARES             = sudoku._cross(ROWS, COLS);\n        UNITS               = sudoku._get_all_units(ROWS, COLS);\n        SQUARE_UNITS_MAP    = sudoku._get_square_units_map(SQUARES, UNITS);\n        SQUARE_PEERS_MAP    = sudoku._get_square_peers_map(SQUARES,\n                                    SQUARE_UNITS_MAP);\n    }\n\n    // Generate\n    // -------------------------------------------------------------------------\n    sudoku.generate = function(difficulty, unique){\n        /* Generate a new Sudoku puzzle of a particular `difficulty`, e.g.,\n\n            // Generate an \"easy\" sudoku puzzle\n            sudoku.generate(\"easy\");\n\n\n        Difficulties are as follows, and represent the number of given squares:\n\n                \"easy\":         61\n                \"medium\":       52\n                \"hard\":         43\n                \"very-hard\":    34\n                \"insane\":       25\n                \"inhuman\":      17\n\n\n        You may also enter a custom number of squares to be given, e.g.,\n\n            // Generate a new Sudoku puzzle with 60 given squares\n            sudoku.generate(60)\n\n\n        `difficulty` must be a number between 17 and 81 inclusive. If it's\n        outside of that range, `difficulty` will be set to the closest bound,\n        e.g., 0 -> 17, and 100 -> 81.\n\n\n        By default, the puzzles are unique, uless you set `unique` to false.\n        (Note: Puzzle uniqueness is not yet implemented, so puzzles are *not*\n        guaranteed to have unique solutions)\n\n        TODO: Implement puzzle uniqueness\n        */\n\n        // If `difficulty` is a string or undefined, convert it to a number or\n        // default it to \"easy\" if undefined.\n        if(typeof difficulty === \"string\" || typeof difficulty === \"undefined\"){\n            difficulty = DIFFICULTY[difficulty] || DIFFICULTY.easy;\n        }\n\n        // Force difficulty between 17 and 81 inclusive\n        difficulty = sudoku._force_range(difficulty, NR_SQUARES + 1,\n                MIN_GIVENS);\n\n        // Default unique to true\n        unique = unique || true;\n\n        // Get a set of squares and all possible candidates for each square\n        var blank_board = \"\";\n        for(var i = 0; i < NR_SQUARES; ++i){\n            blank_board += '.';\n        }\n        var candidates = sudoku._get_candidates_map(blank_board);\n\n        // For each item in a shuffled list of squares\n        var shuffled_squares = sudoku._shuffle(SQUARES);\n        for(var si in shuffled_squares){\n            var square = shuffled_squares[si];\n\n            // If an assignment of a random chioce causes a contradictoin, give\n            // up and try again\n            var rand_candidate_idx =\n                    sudoku._rand_range(candidates[square].length);\n            var rand_candidate = candidates[square][rand_candidate_idx];\n            if(!sudoku._assign(candidates, square, rand_candidate)){\n                break;\n            }\n\n            // Make a list of all single candidates\n            var single_candidates = [];\n            for(si in SQUARES){\n                square = SQUARES[si];\n\n                if(candidates[square].length === 1){\n                    single_candidates.push(candidates[square]);\n                }\n            }\n\n            // If we have at least difficulty, and the unique candidate count is\n            // at least 8, return the puzzle!\n            if(single_candidates.length >= difficulty &&\n                    sudoku._strip_dups(single_candidates).length >= 8){\n                var board = \"\";\n                var givens_idxs = [];\n                for(i in SQUARES){\n                    square = SQUARES[i];\n                    if(candidates[square].length === 1){\n                        board += candidates[square];\n                        givens_idxs.push(i);\n                    } else {\n                        board += sudoku.BLANK_CHAR;\n                    }\n                }\n\n                // If we have more than `difficulty` givens, remove some random\n                // givens until we're down to exactly `difficulty`\n                var nr_givens = givens_idxs.length;\n                if(nr_givens > difficulty){\n                    givens_idxs = sudoku._shuffle(givens_idxs);\n                    for(i = 0; i < nr_givens - difficulty; ++i){\n                        var target = parseInt(givens_idxs[i]);\n                        board = board.substr(0, target) + sudoku.BLANK_CHAR +\n                            board.substr(target + 1);\n                    }\n                }\n\n                // Double check board is solvable\n                // TODO: Make a standalone board checker. Solve is expensive.\n                if(sudoku.solve(board)){\n                    return board;\n                }\n            }\n        }\n\n        // Give up and try a new puzzle\n        return sudoku.generate(difficulty);\n    };\n\n    // Solve\n    // -------------------------------------------------------------------------\n    sudoku.solve = function(board, reverse){\n        /* Solve a sudoku puzzle given a sudoku `board`, i.e., an 81-character\n        string of sudoku.DIGITS, 1-9, and spaces identified by '.', representing the\n        squares. There must be a minimum of 17 givens. If the given board has no\n        solutions, return false.\n\n        Optionally set `reverse` to solve \"backwards\", i.e., rotate through the\n        possibilities in reverse. Useful for checking if there is more than one\n        solution.\n        */\n\n        // Assure a valid board\n        var report = sudoku.validate_board(board);\n        if(report !== true){\n            throw report;\n        }\n\n        // Check number of givens is at least MIN_GIVENS\n        var nr_givens = 0;\n        for(var i in board){\n            if(board[i] !== sudoku.BLANK_CHAR && sudoku._in(board[i], sudoku.DIGITS)){\n                ++nr_givens;\n            }\n        }\n        if(nr_givens < MIN_GIVENS){\n            // eslint-disable-next-line\n            throw \"Too few givens. Minimum givens is \" + MIN_GIVENS;\n        }\n\n        // Default reverse to false\n        reverse = reverse || false;\n\n        var candidates = sudoku._get_candidates_map(board);\n        var result = sudoku._search(candidates, reverse);\n\n        if(result){\n            var solution = \"\";\n            for(var square in result){\n                solution += result[square];\n            }\n            return solution;\n        }\n        return false;\n    };\n\n    sudoku.get_candidates = function(board){\n        /* Return all possible candidatees for each square as a grid of\n        candidates, returnning `false` if a contradiction is encountered.\n\n        Really just a wrapper for sudoku._get_candidates_map for programmer\n        consumption.\n        */\n\n        // Assure a valid board\n        var report = sudoku.validate_board(board);\n        if(report !== true){\n            throw report;\n        }\n\n        // Get a candidates map\n        var candidates_map = sudoku._get_candidates_map(board);\n\n        // If there's an error, return false\n        if(!candidates_map){\n            return false;\n        }\n\n        // Transform candidates map into grid\n        var rows = [];\n        var cur_row = [];\n        var i = 0;\n        for(var square in candidates_map){\n            var candidates = candidates_map[square];\n            cur_row.push(candidates);\n            if(i % 9 === 8){\n                rows.push(cur_row);\n                cur_row = [];\n            }\n            ++i;\n        }\n        return rows;\n    }\n\n    sudoku._get_candidates_map = function(board){\n        /* Get all possible candidates for each square as a map in the form\n        {square: sudoku.DIGITS} using recursive constraint propagation. Return `false`\n        if a contradiction is encountered\n        */\n\n        // Assure a valid board\n        var report = sudoku.validate_board(board);\n        if(report !== true){\n            throw report;\n        }\n\n        var candidate_map = {};\n        var squares_values_map = sudoku._get_square_vals_map(board);\n\n        // Start by assigning every digit as a candidate to every square\n        for(var si in SQUARES){\n            candidate_map[SQUARES[si]] = sudoku.DIGITS;\n        }\n\n        // For each non-blank square, assign its value in the candidate map and\n        // propigate.\n        for(var square in squares_values_map){\n            var val = squares_values_map[square];\n\n            if(sudoku._in(val, sudoku.DIGITS)){\n                var new_candidates = sudoku._assign(candidate_map, square, val);\n\n                // Fail if we can't assign val to square\n                if(!new_candidates){\n                    return false;\n                }\n            }\n        }\n\n        return candidate_map;\n    };\n\n    sudoku._search = function(candidates, reverse){\n        /* Given a map of squares -> candiates, using depth-first search,\n        recursively try all possible values until a solution is found, or false\n        if no solution exists.\n        */\n\n        // Return if error in previous iteration\n        if(!candidates){\n            return false;\n        }\n\n        // Default reverse to false\n        reverse = reverse || false;\n\n        // If only one candidate for every square, we've a solved puzzle!\n        // Return the candidates map.\n        var max_nr_candidates = 0;\n        // eslint-disable-next-line\n        var max_candidates_square = null;\n        for(var si in SQUARES){\n            var square = SQUARES[si];\n\n            var nr_candidates = candidates[square].length;\n\n            if(nr_candidates > max_nr_candidates){\n                max_nr_candidates = nr_candidates;\n                // eslint-disable-next-line no-unused-vars\n                max_candidates_square = square;\n            }\n        }\n        if(max_nr_candidates === 1){\n            return candidates;\n        }\n\n        // Choose the blank square with the fewest possibilities > 1\n        var min_nr_candidates = 10;\n        var min_candidates_square = null;\n        for(si in SQUARES){\n            square = SQUARES[si];\n\n            nr_candidates = candidates[square].length;\n\n            if(nr_candidates < min_nr_candidates && nr_candidates > 1){\n                min_nr_candidates = nr_candidates;\n                min_candidates_square = square;\n            }\n        }\n\n        // Recursively search through each of the candidates of the square\n        // starting with the one with fewest candidates.\n\n        // Rotate through the candidates forwards\n        var min_candidates = candidates[min_candidates_square];\n        if(!reverse){\n            for(var vi in min_candidates){\n                var val = min_candidates[vi];\n\n                // TODO: Implement a non-rediculous deep copy function\n                var candidates_copy = JSON.parse(JSON.stringify(candidates));\n                var candidates_next = sudoku._search(\n                    sudoku._assign(candidates_copy, min_candidates_square, val)\n                );\n\n                if(candidates_next){\n                    return candidates_next;\n                }\n            }\n\n        // Rotate through the candidates backwards\n        } else {\n            for(vi = min_candidates.length - 1; vi >= 0; --vi){\n                val = min_candidates[vi];\n\n                // TODO: Implement a non-rediculous deep copy function\n                candidates_copy = JSON.parse(JSON.stringify(candidates));\n                candidates_next = sudoku._search(\n                    sudoku._assign(candidates_copy, min_candidates_square, val),\n                    reverse\n                );\n\n                if(candidates_next){\n                    return candidates_next;\n                }\n            }\n        }\n\n        // If we get through all combinations of the square with the fewest\n        // candidates without finding an answer, there isn't one. Return false.\n        return false;\n    };\n\n    sudoku._assign = function(candidates, square, val){\n        /* Eliminate all values, *except* for `val`, from `candidates` at\n        `square` (candidates[square]), and propagate. Return the candidates map\n        when finished. If a contradiciton is found, return false.\n\n        WARNING: This will modify the contents of `candidates` directly.\n        */\n\n        // Grab a list of canidates without 'val'\n        var other_vals = candidates[square].replace(val, \"\");\n\n        // Loop through all other values and eliminate them from the candidates\n        // at the current square, and propigate. If at any point we get a\n        // contradiction, return false.\n        for(var ovi in other_vals){\n            var other_val = other_vals[ovi];\n\n            var candidates_next =\n                sudoku._eliminate(candidates, square, other_val);\n\n            if(!candidates_next){\n                //console.log(\"Contradiction found by _eliminate.\");\n                return false;\n            }\n        }\n\n        return candidates;\n    };\n\n    sudoku._eliminate = function(candidates, square, val){\n        /* Eliminate `val` from `candidates` at `square`, (candidates[square]),\n        and propagate when values or places <= 2. Return updated candidates,\n        unless a contradiction is detected, in which case, return false.\n\n        WARNING: This will modify the contents of `candidates` directly.\n        */\n\n        // If `val` has already been eliminated from candidates[square], return\n        // with candidates.\n        if(!sudoku._in(val, candidates[square])){\n            return candidates;\n        }\n\n        // Remove `val` from candidates[square]\n        candidates[square] = candidates[square].replace(val, '');\n\n        // If the square has only candidate left, eliminate that value from its\n        // peers\n        var nr_candidates = candidates[square].length;\n        if(nr_candidates === 1){\n            var target_val = candidates[square];\n\n            for(var pi in SQUARE_PEERS_MAP[square]){\n                var peer = SQUARE_PEERS_MAP[square][pi];\n\n                var candidates_new =\n                        sudoku._eliminate(candidates, peer, target_val);\n\n                if(!candidates_new){\n                    return false;\n                }\n            }\n\n        // Otherwise, if the square has no candidates, we have a contradiction.\n        // Return false.\n        } if(nr_candidates === 0){\n            return false;\n        }\n\n        // If a unit is reduced to only one place for a value, then assign it\n        for(var ui in SQUARE_UNITS_MAP[square]){\n            var unit = SQUARE_UNITS_MAP[square][ui];\n\n            var val_places = [];\n            for(var si in unit){\n                var unit_square = unit[si];\n                if(sudoku._in(val, candidates[unit_square])){\n                    val_places.push(unit_square);\n                }\n            }\n\n            // If there's no place for this value, we have a contradition!\n            // return false\n            if(val_places.length === 0){\n                return false;\n\n            // Otherwise the value can only be in one place. Assign it there.\n            } else if(val_places.length === 1){\n                candidates_new =\n                    sudoku._assign(candidates, val_places[0], val);\n\n                if(!candidates_new){\n                    return false;\n                }\n            }\n        }\n\n        return candidates;\n    };\n\n\n    // Square relationships\n    // -------------------------------------------------------------------------\n    // Squares, and their relationships with values, units, and peers.\n\n    sudoku._get_square_vals_map = function(board){\n        /* Return a map of squares -> values\n        */\n        var squares_vals_map = {};\n\n        // Make sure `board` is a string of length 81\n        if(board.length !== SQUARES.length){\n            // eslint-disable-next-line\n            throw \"Board/squares length mismatch.\";\n\n        } else {\n            for(var i in SQUARES){\n                squares_vals_map[SQUARES[i]] = board[i];\n            }\n        }\n\n        return squares_vals_map;\n    };\n\n    sudoku._get_square_units_map = function(squares, units){\n        /* Return a map of `squares` and their associated units (row, col, box)\n        */\n        var square_unit_map = {};\n\n        // For every square...\n        for(var si in squares){\n            var cur_square = squares[si];\n\n            // Maintain a list of the current square's units\n            var cur_square_units = [];\n\n            // Look through the units, and see if the current square is in it,\n            // and if so, add it to the list of of the square's units.\n            for(var ui in units){\n                var cur_unit = units[ui];\n\n                if(cur_unit.indexOf(cur_square) !== -1){\n                    cur_square_units.push(cur_unit);\n                }\n            }\n\n            // Save the current square and its units to the map\n            square_unit_map[cur_square] = cur_square_units;\n        }\n\n        return square_unit_map;\n    };\n\n    sudoku._get_square_peers_map = function(squares, units_map){\n        /* Return a map of `squares` and their associated peers, i.e., a set of\n        other squares in the square's unit.\n        */\n        var square_peers_map = {};\n\n        // For every square...\n        for(var si in squares){\n            var cur_square = squares[si];\n            var cur_square_units = units_map[cur_square];\n\n            // Maintain list of the current square's peers\n            var cur_square_peers = [];\n\n            // Look through the current square's units map...\n            for(var sui in cur_square_units){\n                var cur_unit = cur_square_units[sui];\n\n                for(var ui in cur_unit){\n                    var cur_unit_square = cur_unit[ui];\n\n                    if(cur_square_peers.indexOf(cur_unit_square) === -1 &&\n                            cur_unit_square !== cur_square){\n                        cur_square_peers.push(cur_unit_square);\n                    }\n                }\n            }\n\n            // Save the current square an its associated peers to the map\n            square_peers_map[cur_square] = cur_square_peers;\n        }\n\n        return square_peers_map;\n    };\n\n    sudoku._get_all_units = function(rows, cols){\n        /* Return a list of all units (rows, cols, boxes)\n        */\n        var units = [];\n\n        // Rows\n        for(var ri in rows){\n            units.push(sudoku._cross(rows[ri], cols));\n        }\n\n        // Columns\n        for(var ci in cols){\n           units.push(sudoku._cross(rows, cols[ci]));\n        }\n\n        // Boxes\n        var row_squares = [\"ABC\", \"DEF\", \"GHI\"];\n        var col_squares = [\"123\", \"456\", \"789\"];\n        for(var rsi in row_squares){\n            for(var csi in col_squares){\n                units.push(sudoku._cross(row_squares[rsi], col_squares[csi]));\n            }\n        }\n\n        return units;\n    };\n\n\n    // Conversions\n    // -------------------------------------------------------------------------\n    sudoku.board_string_to_grid = function(board_string){\n        /* Convert a board string to a two-dimensional array\n        */\n        var rows = [];\n        var cur_row = [];\n        for(var i in board_string){\n            cur_row.push(board_string[i]);\n            if(i % 9 === 8){\n                rows.push(cur_row);\n                cur_row = [];\n            }\n        }\n        return rows;\n    };\n\n    sudoku.board_grid_to_string = function(board_grid){\n        /* Convert a board grid to a string\n        */\n        var board_string = \"\";\n        for(var r = 0; r < 9; ++r){\n            for(var c = 0; c < 9; ++c){\n                board_string += board_grid[r][c];\n            }\n        }\n        return board_string;\n    };\n\n\n    // Utility\n    // -------------------------------------------------------------------------\n\n    sudoku.print_board = function(board){\n        /* Print a sudoku `board` to the console.\n        */\n\n        // Assure a valid board\n        var report = sudoku.validate_board(board);\n        if(report !== true){\n            throw report;\n        }\n\n        var V_PADDING = \" \";  // Insert after each square\n        var H_PADDING = '\\n'; // Insert after each row\n\n        var V_BOX_PADDING = \"  \"; // Box vertical padding\n        var H_BOX_PADDING = '\\n'; // Box horizontal padding\n\n        var display_string = \"\";\n\n        for(var i in board){\n            var square = board[i];\n\n            // Add the square and some padding\n            display_string += square + V_PADDING;\n\n            // Vertical edge of a box, insert v. box padding\n            if(i % 3 === 2){\n                display_string += V_BOX_PADDING;\n            }\n\n            // End of a line, insert horiz. padding\n            if(i % 9 === 8){\n                display_string += H_PADDING;\n            }\n\n            // Horizontal edge of a box, insert h. box padding\n            if(i % 27 === 26){\n                display_string += H_BOX_PADDING;\n            }\n        }\n\n        console.log(display_string);\n    };\n\n    sudoku.validate_board = function(board){\n        /* Return if the given `board` is valid or not. If it's valid, return\n        true. If it's not, return a string of the reason why it's not.\n        */\n\n        // Check for empty board\n        if(!board){\n            return \"Empty board\";\n        }\n\n        // Invalid board length\n        if(board.length !== NR_SQUARES){\n            return \"Invalid board size. Board must be exactly \" + NR_SQUARES +\n                    \" squares.\";\n        }\n\n        // Check for invalid characters\n        for(var i in board){\n            if(!sudoku._in(board[i], sudoku.DIGITS) && board[i] !== sudoku.BLANK_CHAR){\n                return \"Invalid board character encountered at index \" + i +\n                        \": \" + board[i];\n            }\n        }\n\n        // Otherwise, we're good. Return true.\n        return true;\n    };\n\n    sudoku._cross = function(a, b){\n        /* Cross product of all elements in `a` and `b`, e.g.,\n        sudoku._cross(\"abc\", \"123\") ->\n        [\"a1\", \"a2\", \"a3\", \"b1\", \"b2\", \"b3\", \"c1\", \"c2\", \"c3\"]\n        */\n        var result = [];\n        for(var ai in a){\n            for(var bi in b){\n                result.push(a[ai] + b[bi]);\n            }\n        }\n        return result;\n    };\n\n    sudoku._in = function(v, seq){\n        /* Return if a value `v` is in sequence `seq`.\n        */\n        return seq.indexOf(v) !== -1;\n    };\n\n    sudoku._first_true = function(seq){\n        /* Return the first element in `seq` that is true. If no element is\n        true, return false.\n        */\n        for(var i in seq){\n            if(seq[i]){\n                return seq[i];\n            }\n        }\n        return false;\n    };\n\n    sudoku._shuffle = function(seq){\n        /* Return a shuffled version of `seq`\n        */\n\n        // Create an array of the same size as `seq` filled with false\n        var shuffled = [];\n        for(var i = 0; i < seq.length; ++i){\n            shuffled.push(false);\n        }\n\n        for(i in seq){\n            var ti = sudoku._rand_range(seq.length);\n\n            while(shuffled[ti]){\n                ti = (ti + 1) > (seq.length - 1) ? 0 : (ti + 1);\n            }\n\n            shuffled[ti] = seq[i];\n        }\n\n        return shuffled;\n    };\n\n    sudoku._rand_range = function(max, min){\n        /* Get a random integer in the range of `min` to `max` (non inclusive).\n        If `min` not defined, default to 0. If `max` not defined, throw an\n        error.\n        */\n        min = min || 0;\n        if(max){\n            return Math.floor(Math.random() * (max - min)) + min;\n        } else {\n            // eslint-disable-next-line\n            throw \"Range undefined\";\n        }\n    };\n\n    sudoku._strip_dups = function(seq){\n        /* Strip duplicate values from `seq`\n        */\n        var seq_set = [];\n        var dup_map = {};\n        for(var i in seq){\n            var e = seq[i];\n            if(!dup_map[e]){\n                seq_set.push(e);\n                dup_map[e] = true;\n            }\n        }\n        return seq_set;\n    };\n\n    sudoku._force_range = function(nr, max, min){\n        /* Force `nr` to be within the range from `min` to, but not including,\n        `max`. `min` is optional, and will default to 0. If `nr` is undefined,\n        treat it as zero.\n        */\n        min = min || 0\n        nr = nr || 0\n        if(nr < min){\n            return min;\n        }\n        if(nr > max){\n            return max;\n        }\n        return nr\n    }\n\n    // Initialize library after load\n    initialize();\n\n    export const getSudoku = () => {\n      return sudoku;\n    }\n\n// Pass whatever the root object is, like 'window' in browsers\n//})(this);\n"]},"metadata":{},"sourceType":"module"}