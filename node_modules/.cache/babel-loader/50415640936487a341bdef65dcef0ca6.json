{"ast":null,"code":"import AggregateError from 'aggregate-error';\nexport default async function pMap(iterable, mapper) {\n  let {\n    concurrency = Number.POSITIVE_INFINITY,\n    stopOnError = true\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return new Promise((resolve, reject_) => {\n    // eslint-disable-line promise/param-names\n    if (iterable[Symbol.iterator] === undefined && iterable[Symbol.asyncIterator] === undefined) {\n      throw new TypeError(`Expected \\`input\\` to be either an \\`Iterable\\` or \\`AsyncIterable\\`, got (${typeof iterable})`);\n    }\n\n    if (typeof mapper !== 'function') {\n      throw new TypeError('Mapper function is required');\n    }\n\n    if (!((Number.isSafeInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency >= 1)) {\n      throw new TypeError(`Expected \\`concurrency\\` to be an integer from 1 and up or \\`Infinity\\`, got \\`${concurrency}\\` (${typeof concurrency})`);\n    }\n\n    const result = [];\n    const errors = [];\n    const skippedIndexesMap = new Map();\n    let isRejected = false;\n    let isResolved = false;\n    let isIterableDone = false;\n    let resolvingCount = 0;\n    let currentIndex = 0;\n    const iterator = iterable[Symbol.iterator] === undefined ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();\n\n    const reject = reason => {\n      isRejected = true;\n      isResolved = true;\n      reject_(reason);\n    };\n\n    const next = async () => {\n      if (isResolved) {\n        return;\n      }\n\n      const nextItem = await iterator.next();\n      const index = currentIndex;\n      currentIndex++; // Note: `iterator.next()` can be called many times in parallel.\n      // This can cause multiple calls to this `next()` function to\n      // receive a `nextItem` with `done === true`.\n      // The shutdown logic that rejects/resolves must be protected\n      // so it runs only one time as the `skippedIndex` logic is\n      // non-idempotent.\n\n      if (nextItem.done) {\n        isIterableDone = true;\n\n        if (resolvingCount === 0 && !isResolved) {\n          if (!stopOnError && errors.length > 0) {\n            reject(new AggregateError(errors));\n            return;\n          }\n\n          isResolved = true;\n\n          if (!skippedIndexesMap.size) {\n            resolve(result);\n            return;\n          }\n\n          const pureResult = []; // Support multiple `pMapSkip`'s.\n\n          for (const [index, value] of result.entries()) {\n            if (skippedIndexesMap.get(index) === pMapSkip) {\n              continue;\n            }\n\n            pureResult.push(value);\n          }\n\n          resolve(pureResult);\n        }\n\n        return;\n      }\n\n      resolvingCount++; // Intentionally detached\n\n      (async () => {\n        try {\n          const element = await nextItem.value;\n\n          if (isResolved) {\n            return;\n          }\n\n          const value = await mapper(element, index); // Use Map to stage the index of the element.\n\n          if (value === pMapSkip) {\n            skippedIndexesMap.set(index, value);\n          }\n\n          result[index] = value;\n          resolvingCount--;\n          await next();\n        } catch (error) {\n          if (stopOnError) {\n            reject(error);\n          } else {\n            errors.push(error);\n            resolvingCount--; // In that case we can't really continue regardless of `stopOnError` state\n            // since an iterable is likely to continue throwing after it throws once.\n            // If we continue calling `next()` indefinitely we will likely end up\n            // in an infinite loop of failed iteration.\n\n            try {\n              await next();\n            } catch (error) {\n              reject(error);\n            }\n          }\n        }\n      })();\n    }; // Create the concurrent runners in a detached (non-awaited)\n    // promise. We need this so we can await the `next()` calls\n    // to stop creating runners before hitting the concurrency limit\n    // if the iterable has already been marked as done.\n    // NOTE: We *must* do this for async iterators otherwise we'll spin up\n    // infinite `next()` calls by default and never start the event loop.\n\n\n    (async () => {\n      for (let index = 0; index < concurrency; index++) {\n        try {\n          // eslint-disable-next-line no-await-in-loop\n          await next();\n        } catch (error) {\n          reject(error);\n          break;\n        }\n\n        if (isIterableDone || isRejected) {\n          break;\n        }\n      }\n    })();\n  });\n}\nexport const pMapSkip = Symbol('skip');","map":{"version":3,"sources":["C:/Users/admin/Downloads/Future/personal-project/node_modules/pokedex-promise-v2/node_modules/p-map/index.js"],"names":["AggregateError","pMap","iterable","mapper","concurrency","Number","POSITIVE_INFINITY","stopOnError","Promise","resolve","reject_","Symbol","iterator","undefined","asyncIterator","TypeError","isSafeInteger","result","errors","skippedIndexesMap","Map","isRejected","isResolved","isIterableDone","resolvingCount","currentIndex","reject","reason","next","nextItem","index","done","length","size","pureResult","value","entries","get","pMapSkip","push","element","set","error"],"mappings":"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","sourcesContent":["import AggregateError from 'aggregate-error';\n\nexport default async function pMap(\n\titerable,\n\tmapper,\n\t{\n\t\tconcurrency = Number.POSITIVE_INFINITY,\n\t\tstopOnError = true\n\t} = {}\n) {\n\treturn new Promise((resolve, reject_) => { // eslint-disable-line promise/param-names\n\t\tif (iterable[Symbol.iterator] === undefined && iterable[Symbol.asyncIterator] === undefined) {\n\t\t\tthrow new TypeError(`Expected \\`input\\` to be either an \\`Iterable\\` or \\`AsyncIterable\\`, got (${typeof iterable})`);\n\t\t}\n\n\t\tif (typeof mapper !== 'function') {\n\t\t\tthrow new TypeError('Mapper function is required');\n\t\t}\n\n\t\tif (!((Number.isSafeInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency >= 1)) {\n\t\t\tthrow new TypeError(`Expected \\`concurrency\\` to be an integer from 1 and up or \\`Infinity\\`, got \\`${concurrency}\\` (${typeof concurrency})`);\n\t\t}\n\n\t\tconst result = [];\n\t\tconst errors = [];\n\t\tconst skippedIndexesMap = new Map();\n\t\tlet isRejected = false;\n\t\tlet isResolved = false;\n\t\tlet isIterableDone = false;\n\t\tlet resolvingCount = 0;\n\t\tlet currentIndex = 0;\n\t\tconst iterator = iterable[Symbol.iterator] === undefined ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();\n\n\t\tconst reject = reason => {\n\t\t\tisRejected = true;\n\t\t\tisResolved = true;\n\t\t\treject_(reason);\n\t\t};\n\n\t\tconst next = async () => {\n\t\t\tif (isResolved) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst nextItem = await iterator.next();\n\n\t\t\tconst index = currentIndex;\n\t\t\tcurrentIndex++;\n\n\t\t\t// Note: `iterator.next()` can be called many times in parallel.\n\t\t\t// This can cause multiple calls to this `next()` function to\n\t\t\t// receive a `nextItem` with `done === true`.\n\t\t\t// The shutdown logic that rejects/resolves must be protected\n\t\t\t// so it runs only one time as the `skippedIndex` logic is\n\t\t\t// non-idempotent.\n\t\t\tif (nextItem.done) {\n\t\t\t\tisIterableDone = true;\n\n\t\t\t\tif (resolvingCount === 0 && !isResolved) {\n\t\t\t\t\tif (!stopOnError && errors.length > 0) {\n\t\t\t\t\t\treject(new AggregateError(errors));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tisResolved = true;\n\n\t\t\t\t\tif (!skippedIndexesMap.size) {\n\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst pureResult = [];\n\n\t\t\t\t\t// Support multiple `pMapSkip`'s.\n\t\t\t\t\tfor (const [index, value] of result.entries()) {\n\t\t\t\t\t\tif (skippedIndexesMap.get(index) === pMapSkip) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpureResult.push(value);\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve(pureResult);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresolvingCount++;\n\n\t\t\t// Intentionally detached\n\t\t\t(async () => {\n\t\t\t\ttry {\n\t\t\t\t\tconst element = await nextItem.value;\n\n\t\t\t\t\tif (isResolved) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst value = await mapper(element, index);\n\n\t\t\t\t\t// Use Map to stage the index of the element.\n\t\t\t\t\tif (value === pMapSkip) {\n\t\t\t\t\t\tskippedIndexesMap.set(index, value);\n\t\t\t\t\t}\n\n\t\t\t\t\tresult[index] = value;\n\n\t\t\t\t\tresolvingCount--;\n\t\t\t\t\tawait next();\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (stopOnError) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t} else {\n\t\t\t\t\t\terrors.push(error);\n\t\t\t\t\t\tresolvingCount--;\n\n\t\t\t\t\t\t// In that case we can't really continue regardless of `stopOnError` state\n\t\t\t\t\t\t// since an iterable is likely to continue throwing after it throws once.\n\t\t\t\t\t\t// If we continue calling `next()` indefinitely we will likely end up\n\t\t\t\t\t\t// in an infinite loop of failed iteration.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait next();\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})();\n\t\t};\n\n\t\t// Create the concurrent runners in a detached (non-awaited)\n\t\t// promise. We need this so we can await the `next()` calls\n\t\t// to stop creating runners before hitting the concurrency limit\n\t\t// if the iterable has already been marked as done.\n\t\t// NOTE: We *must* do this for async iterators otherwise we'll spin up\n\t\t// infinite `next()` calls by default and never start the event loop.\n\t\t(async () => {\n\t\t\tfor (let index = 0; index < concurrency; index++) {\n\t\t\t\ttry {\n\t\t\t\t\t// eslint-disable-next-line no-await-in-loop\n\t\t\t\t\tawait next();\n\t\t\t\t} catch (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (isIterableDone || isRejected) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t})();\n\t});\n}\n\nexport const pMapSkip = Symbol('skip');\n"]},"metadata":{},"sourceType":"module"}