{"ast":null,"code":"const VALID_VALUES = [1, 2, 3, 4, 5, 6, 7, 8, 9];\nexport function isValidValue(value) {\n  // empty string denotes empty cells\n  if (value === '') {\n    return true;\n  }\n\n  if (isNaN(value)) {\n    return false;\n  }\n\n  return VALID_VALUES.indexOf(value) !== -1;\n}\n/**\n * Validates that a cell contains a valid value that is not\n * used in it's peers.\n *\n * @param x index of the cell being checked\n * @param y index of the cell being checked\n * @param sudoku the board being checked\n */\n\nexport function isCellValid(x, y, sudoku) {\n  const value = sudoku[x][y]; // empty cells are always valid\n\n  if (value === '') {\n    return true;\n  } // check peer list for this value being used else where\n\n\n  const peers = getPeers(x, y);\n\n  for (const peer of peers) {\n    if (sudoku[peer.x][peer.y] === value) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Returns the list of cells that are peers to this cell.\n * This includes all cells in same row and column as well as\n * the cells in the same grid.\n * @param int x\n * @param int y\n */\n\nexport function getPeers(x, y) {\n  let peers = []; // add all y's and x's\n\n  for (let k = 0; k < 9; k++) {\n    if (k !== x) {\n      peers.push({\n        x: k,\n        y\n      });\n    }\n\n    if (k !== y) {\n      peers.push({\n        x,\n        y: k\n      });\n    }\n  } // add the items in the same grid\n\n\n  const topLeftY = y - y % 3;\n  const topLeftX = x - x % 3;\n\n  for (let i = topLeftX; i < topLeftX + 3; i++) {\n    for (let j = topLeftY; j < topLeftY + 3; j++) {\n      if (j === y && i === x) {\n        continue;\n      }\n\n      peers.push({\n        x: i,\n        y: j\n      });\n    }\n  }\n\n  return peers;\n}\n/**\n * Solves a sudoku puzzle.\n * @param sudoku the puzzle to be solved\n */\n\nexport function solve(sudoku) {\n  // copy input\n  let puzzle = [[...sudoku[0]], [...sudoku[1]], [...sudoku[2]], [...sudoku[3]], [...sudoku[4]], [...sudoku[5]], [...sudoku[6]], [...sudoku[7]], [...sudoku[8]]];\n  let cycleImprovedAnswer = true;\n  let remainingCells = [];\n\n  while (cycleImprovedAnswer) {\n    cycleImprovedAnswer = false;\n    remainingCells = []; // do a cycle and look for cells where their is only one possible value\n\n    for (let x = 0; x < 9; x++) {\n      for (let y = 0; y < 9; y++) {\n        const value = puzzle[x][y];\n\n        if (value) {\n          continue; // this cell is populated, skip to the next\n        } // get list of values in all peers\n\n\n        const peers = getPeers(x, y);\n        let usedValues = [];\n\n        for (var peer of peers) {\n          usedValues.push(puzzle[peer.x][peer.y]);\n        } // see what possibile values remain\n\n\n        const possibleValues = VALID_VALUES.filter(value => usedValues.indexOf(value) === -1);\n\n        if (possibleValues.length === 1) {\n          puzzle[x][y] = possibleValues[0];\n          cycleImprovedAnswer = true;\n        } else if (possibleValues.length === 0) {\n          alert('Input is a unsolvable puzzle.');\n          return [['', '', '', '', '', '', '', '', ''], ['', '', '', '', '', '', '', '', ''], ['', '', '', '', '', '', '', '', ''], ['', '', '', '', '', '', '', '', ''], ['', '', '', '', '', '', '', '', ''], ['', '', '', '', '', '', '', '', ''], ['', '', '', '', '', '', '', '', ''], ['', '', '', '', '', '', '', '', ''], ['', '', '', '', '', '', '', '', '']];\n        } else {\n          remainingCells.push({\n            x,\n            y,\n            possibleValues\n          });\n        }\n      }\n    }\n  } // Now use brute force to solve the remaining ambiguous cells.\n  // Use the list of possible values from the peer evaluation to limit the search space.\n\n\n  for (let i = 0; i < remainingCells.length; i++) {\n    const {\n      x,\n      y,\n      possibleValues\n    } = remainingCells[i];\n    let value = puzzle[x][y];\n\n    if (!value) {\n      value = possibleValues[0];\n    } else {\n      const indexOfCurrentValue = possibleValues.indexOf(value);\n\n      if (indexOfCurrentValue >= possibleValues.length - 1) {\n        // We are out of values for this cell backtrack on cell\n        puzzle[x][y] = '';\n        i = i - 2;\n        continue;\n      }\n\n      value = possibleValues[indexOfCurrentValue + 1];\n    }\n\n    puzzle[x][y] = value;\n\n    if (!isCellValid(x, y, puzzle)) {\n      i = i - 1; // this new square value is not valid\n\n      continue;\n    }\n  }\n\n  return puzzle;\n}","map":{"version":3,"sources":["C:/Users/admin/Downloads/Future/personal-project/src/pages/Sudoku/store/solverUtils.js"],"names":["VALID_VALUES","isValidValue","value","isNaN","indexOf","isCellValid","x","y","sudoku","peers","getPeers","peer","k","push","topLeftY","topLeftX","i","j","solve","puzzle","cycleImprovedAnswer","remainingCells","usedValues","possibleValues","filter","length","alert","indexOfCurrentValue"],"mappings":"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","sourcesContent":["const VALID_VALUES = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nexport function isValidValue(value) {\n    // empty string denotes empty cells\n    if (value === '') {\n        return true\n    }\n    if (isNaN(value)) {\n        return false;\n    }\n    return VALID_VALUES.indexOf(value) !== -1\n}\n\n/**\n * Validates that a cell contains a valid value that is not\n * used in it's peers.\n *\n * @param x index of the cell being checked\n * @param y index of the cell being checked\n * @param sudoku the board being checked\n */\nexport function isCellValid(x, y, sudoku) {\n    const value = sudoku[x][y]\n    // empty cells are always valid\n    if (value === '') {\n        return true\n    }\n    // check peer list for this value being used else where\n    const peers = getPeers(x, y)\n    for(const peer of peers) {\n        if (sudoku[peer.x][peer.y] === value) {\n            return false\n        }\n    }\n    return true\n}\n\n/**\n * Returns the list of cells that are peers to this cell.\n * This includes all cells in same row and column as well as\n * the cells in the same grid.\n * @param int x\n * @param int y\n */\nexport function getPeers(x, y) {\n    let peers = []\n    // add all y's and x's\n    for(let k = 0; k < 9; k++) {\n        if (k !== x) {\n            peers.push({\n                x: k,\n                y,\n            })\n        }\n        if (k !== y) {\n            peers.push({\n                x,\n                y: k,\n            })\n        }\n    }\n    // add the items in the same grid\n    const topLeftY = y - y % 3\n    const topLeftX = x - x % 3\n    for(let i = topLeftX; i < topLeftX + 3; i++) {\n        for(let j = topLeftY; j < topLeftY + 3; j++) {\n            if (j === y && i === x) {\n                continue\n            }\n            peers.push({\n                x: i,\n                y: j,\n            })\n        }\n    }\n    return peers\n}\n\n/**\n * Solves a sudoku puzzle.\n * @param sudoku the puzzle to be solved\n */\nexport function solve(sudoku) {\n    // copy input\n    let puzzle = [\n        [...sudoku[0]],\n        [...sudoku[1]],\n        [...sudoku[2]],\n        [...sudoku[3]],\n        [...sudoku[4]],\n        [...sudoku[5]],\n        [...sudoku[6]],\n        [...sudoku[7]],\n        [...sudoku[8]],\n    ]\n\n    let cycleImprovedAnswer = true\n    let remainingCells = []\n    while (cycleImprovedAnswer) {\n        cycleImprovedAnswer = false\n        remainingCells = []\n        // do a cycle and look for cells where their is only one possible value\n        for (let x = 0; x < 9; x++) {\n            for (let y = 0; y < 9; y++) {\n                const value = puzzle[x][y]\n                if (value) {\n                    continue // this cell is populated, skip to the next\n                }\n\n                // get list of values in all peers\n                const peers = getPeers(x, y)\n                let usedValues = []\n                for (var peer of peers) {\n                    usedValues.push(puzzle[peer.x][peer.y])\n                }\n\n                // see what possibile values remain\n                const possibleValues = VALID_VALUES.filter(value => usedValues.indexOf(value) === -1)\n                if (possibleValues.length === 1) {\n                    puzzle[x][y] = possibleValues[0]\n                    cycleImprovedAnswer = true\n                } else if (possibleValues.length === 0) {\n                    alert('Input is a unsolvable puzzle.')\n                    return [\n                        ['', '', '', '', '', '', '', '', ''],\n                        ['', '', '', '', '', '', '', '', ''],\n                        ['', '', '', '', '', '', '', '', ''],\n                        ['', '', '', '', '', '', '', '', ''],\n                        ['', '', '', '', '', '', '', '', ''],\n                        ['', '', '', '', '', '', '', '', ''],\n                        ['', '', '', '', '', '', '', '', ''],\n                        ['', '', '', '', '', '', '', '', ''],\n                        ['', '', '', '', '', '', '', '', ''],\n                    ]\n                } else {\n                    remainingCells.push({\n                        x,\n                        y,\n                        possibleValues\n                    })\n                }\n            }\n        }\n    }\n\n    // Now use brute force to solve the remaining ambiguous cells.\n    // Use the list of possible values from the peer evaluation to limit the search space.\n    for (let i = 0; i < remainingCells.length; i++) {\n        const { x, y, possibleValues } = remainingCells[i]\n        let value = puzzle[x][y]\n        if (!value) {\n            value = possibleValues[0]\n        } else {\n            const indexOfCurrentValue = possibleValues.indexOf(value)\n            if (indexOfCurrentValue >= possibleValues.length - 1) {\n                // We are out of values for this cell backtrack on cell\n                puzzle[x][y] = ''\n                i = i - 2\n                continue\n            }\n            value = possibleValues[indexOfCurrentValue + 1]\n        }\n        puzzle[x][y] = value\n        if (!isCellValid(x, y, puzzle)) {\n            i = i - 1 // this new square value is not valid\n            continue\n        }\n    }\n    return puzzle\n}\n"]},"metadata":{},"sourceType":"module"}